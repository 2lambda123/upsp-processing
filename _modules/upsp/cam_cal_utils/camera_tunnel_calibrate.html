
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>upsp.cam_cal_utils.camera_tunnel_calibrate &#8212; uPSP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">uPSP</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file-formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Third-Party Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../swdd.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../known-issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing this work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_apidoc/upsp.html"><code class="docutils literal notranslate"><span class="pre">upsp</span></code> Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for upsp.cam_cal_utils.camera_tunnel_calibrate</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">upsp.cam_cal_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">external_calibrate</span><span class="p">,</span>
    <span class="n">photogrammetry</span><span class="p">,</span>
    <span class="n">parsers</span><span class="p">,</span>
    <span class="n">visualization</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">debug_show_3D_targets</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">debug_show_img_targets</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">debug_show_matches</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="camera_to_tunnel_calibrate"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.camera_tunnel_calibrate.html#upsp.cam_cal_utils.camera_tunnel_calibrate.camera_to_tunnel_calibrate">[docs]</a><span class="k">def</span> <span class="nf">camera_to_tunnel_calibrate</span><span class="p">(</span>
    <span class="n">ctc_dir</span><span class="p">,</span>
    <span class="n">imgs</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">internal_cals</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">manual_detections</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">tunnel_vals</span><span class="p">,</span>  <span class="c1"># Datapoint specific</span>
    <span class="n">tgts_all</span><span class="p">,</span>  <span class="c1"># Test specific</span>
    <span class="n">test_config</span><span class="p">,</span>  <span class="c1"># Test specific</span>
    <span class="n">vis_checker</span><span class="p">,</span>  <span class="c1"># Test specific</span>
    <span class="n">match_thresh</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>  <span class="c1"># Optional</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs camera to tunnel calibration for the given cameras</span>

<span class="sd">    Generates ``camera_to_tunnel`` json files for each given camera and saved in</span>
<span class="sd">    ``ctc_dir``.</span>

<span class="sd">    Any number of cameras can be given to this function. Each camera needs its own entry</span>
<span class="sd">    in `imgs`, `internal_cals`, and `manual_detections`. If there are 10 cameras, each</span>
<span class="sd">    of those inputs will be a list of length 10.</span>

<span class="sd">    If `debug_show_matches` or `debug_show_img_targets` are True, the debug images will</span>
<span class="sd">    be saved to the current directory. Each image will be appended with &#39;_?&#39; where ? is</span>
<span class="sd">    the index of the camera (If ? is 0, it corresponds to ``imgs[0]``,</span>
<span class="sd">    ``internal_cals[0]``, and ``manual_detections[0]``)</span>

<span class="sd">    All inputs should correspond to the same test configuration. The inputs</span>
<span class="sd">    `tunnel_vals`, `tgts_all`, `test_config`, and `vis_checker` will be used across all</span>
<span class="sd">    cameras.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ctc_dir : string</span>
<span class="sd">        Directory to save the camera-to-tunnel calibrations</span>
<span class="sd">    imgs : list</span>
<span class="sd">        Each image should be ``np.array`` of shape (height, width) and 8-bit.</span>
<span class="sd">        ``imgs[i]`` should correspond to ``internal_cals[i]`` and</span>
<span class="sd">        ``manual_detections[i]``</span>
<span class="sd">    internal_cals : list</span>
<span class="sd">        Each internal calibration should be of the form::</span>

<span class="sd">            [cameraMatrix, distCoeffs, sensor_resolution, sensor_size]</span>

<span class="sd">        - ``cameraMatrix`` is the (openCV formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` is the (openCV formatted) distortion coefficients for the</span>
<span class="sd">          camera</span>
<span class="sd">        - ``sensor_resolution`` is a tuple of the full pixel resolution of the camera</span>
<span class="sd">          (which can be larger than the images of the `imgs` input)</span>
<span class="sd">        - ``sensor_size`` is a tuple of the physical sensor size in inches</span>

<span class="sd">        ``internal_cals[i]`` should correspond to ``imgs[i]`` and</span>
<span class="sd">        ``manual_detections[i]``</span>
<span class="sd">    manual_detections : list</span>
<span class="sd">        Each manual detection using PASCAL VOC format. Each manual detection is a</span>
<span class="sd">        dict with following the keys:</span>

<span class="sd">            - &#39;class&#39; denoting the target_type</span>
<span class="sd">            - &#39;x1&#39; denoting the left edge of the bounding box</span>
<span class="sd">            - &#39;y1&#39; denoting the top edge of the bounding box</span>
<span class="sd">            - &#39;x2&#39; denoting the right edge of the bounding box</span>
<span class="sd">            - &#39;y2&#39; denoting the bottom edge of the bounding box</span>

<span class="sd">        ``manual_detections[i]`` should correspond to ``imgs[i]`` and</span>
<span class="sd">        ``internal_cals[i]``</span>
<span class="sd">    tunnel_vals : dict</span>
<span class="sd">        `tunnel_vals` has the keys ALPHA, BETA, PHI, and STRUTZ which denote the model&#39;s</span>
<span class="sd">        commanded position in the UPWT. For tests without this type of model positioning</span>
<span class="sd">        mechanism, set all values to 0.0</span>
<span class="sd">    tgts_all : list</span>
<span class="sd">        Each target is a dict with (at a minimum) a &#39;target_type&#39;, &#39;tvec&#39;, and &#39;norm&#39;</span>
<span class="sd">        attribute.  The &#39;target_type&#39; is a string for the type of target, usually &#39;dot&#39;.</span>
<span class="sd">        Currently, only targets with the &#39;dot&#39; type are used. The &#39;tvec&#39; attribute gives</span>
<span class="sd">        the target&#39;s location and the &#39;norm&#39; attribute gives the target&#39;s normal vector</span>
<span class="sd">        Both are ``np.array`` vectors with shape (3, 1)</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        The dict must contain the following keys and values:</span>
<span class="sd">            - &#39;oblique_angle&#39; : maximum allowable oblique viewing angle</span>
<span class="sd">            - &#39;max_match_dist&#39; : maximum allowable matching distance between tgt</span>
<span class="sd">              projection and image target</span>
<span class="sd">            - &#39;dot_pad&#39; : pixel padding distance around center of dot target to use for</span>
<span class="sd">              sub-pixel localization</span>
<span class="sd">            - &#39;tunnel-cor_to_tgts_tvec&#39; : translation vector from center of rotation to</span>
<span class="sd">              tgts origin. For tests that do not have a center of rotation like the</span>
<span class="sd">              UPWT, set this value to [0.0, 0.0, 0.0]</span>
<span class="sd">            - &#39;tunnel-cor_to_tgts_rmat&#39; : rotation matrix from center of rotation to</span>
<span class="sd">              tgts origin. For tests that do not have a center of rotation like the</span>
<span class="sd">              UPWT, set this value to [[1, 0, 0], [0, 1, 0], [0, 0, 1]]</span>
<span class="sd">            - &#39;tunnel-cor_to_tunnel-origin_tvec&#39; : translation vector from center of</span>
<span class="sd">              rotation to tunnel origin. This can be [0.0, 0.0, 0.0]</span>
<span class="sd">            - &#39;tunnel-cor_to_tunnel-origin_rmat&#39; : rotation matrix from center of</span>
<span class="sd">              rotation to tunnel origin. This can be [[1, 0, 0], [0, 1, 0], [0, 0, 1]]</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    match_thresh : int or float, default = 0.80</span>
<span class="sd">        Proportion of matched needed to form a consensus, optional default=0.8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make the camera-to-tunnel directory if it does not exist</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ctc_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># For this optimization, only take only the dots from the target inputs if possible</span>
    <span class="n">target_type</span> <span class="o">=</span> <span class="s2">&quot;dot&quot;</span>
    <span class="n">tgts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_all</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;dot&quot;</span><span class="p">:</span>
            <span class="n">tgts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

    <span class="c1"># If there were not enough dots, use kulites</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Set the dot_found flag to False</span>
        <span class="n">target_type</span> <span class="o">=</span> <span class="s2">&quot;kulite&quot;</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_all</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;kulite&quot;</span><span class="p">:</span>
                <span class="n">tgts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug_show_3D_targets</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">target_bumping</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;3D Targets&quot;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>

        <span class="n">tvecs</span><span class="p">,</span> <span class="n">norms</span> <span class="o">=</span> <span class="n">vis_checker</span><span class="o">.</span><span class="n">get_tvecs_and_norms</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="n">internals</span> <span class="o">=</span> <span class="n">target_bumping</span><span class="o">.</span><span class="n">tgts_get_internals</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">)</span>
        <span class="n">internal_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">internal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="n">internals</span><span class="p">]</span>
        <span class="n">external_tgts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">internal_names</span><span class="p">:</span>
                <span class="n">external_tgts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
        <span class="n">visualization</span><span class="o">.</span><span class="n">plot_pts_and_norms</span><span class="p">(</span><span class="n">external_tgts</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">visualization</span><span class="o">.</span><span class="n">axisEqual3D</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;Targets_3D.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;3D Targets&quot;</span><span class="p">)</span>

    <span class="c1"># Get transformation from tunnel frame to tgts frame</span>
    <span class="n">rmat_tunnel_tgts</span><span class="p">,</span> <span class="n">tvec_tunnel_tgts</span> <span class="o">=</span> <span class="n">tunnel_transform</span><span class="p">(</span>
        <span class="o">**</span><span class="n">tunnel_vals</span><span class="p">,</span> <span class="n">tvec__cor_tgts__tgts_frame</span><span class="o">=</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;tunnel-cor_to_tgts_tvec&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">rmat_tgts_tunnel</span><span class="p">,</span> <span class="n">tvec_tgts_tunnel</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">invTransform</span><span class="p">(</span>
        <span class="n">rmat_tunnel_tgts</span><span class="p">,</span> <span class="n">tvec_tunnel_tgts</span>
    <span class="p">)</span>

    <span class="c1"># Run the camera-tunnel calibration for each camera</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">internal_cal</span><span class="p">,</span> <span class="n">manual_detection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">imgs</span><span class="p">,</span> <span class="n">internal_cals</span><span class="p">,</span> <span class="n">manual_detections</span>
    <span class="p">):</span>
        <span class="c1"># Unpackage the internal calibration</span>
        <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">sensor_resolution</span><span class="p">,</span> <span class="n">sensor_size</span> <span class="o">=</span> <span class="n">internal_cal</span>

        <span class="c1"># Get the sub-pixel localized imag_targets</span>
        <span class="n">img_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">manual_detection</span><span class="p">:</span>
            <span class="c1"># If it is a target of the appropriate class, and not flagged as difficult</span>
            <span class="c1">#   add it to the targets list</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_type</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;difficult&quot;</span><span class="p">]:</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">]</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">((</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">img_target</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="n">target_type</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">}</span>
                <span class="n">img_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

        <span class="c1"># Sub-pixel localize the manual img_targets</span>
        <span class="n">__</span><span class="p">,</span> <span class="n">img_targets</span> <span class="o">=</span> <span class="n">external_calibrate</span><span class="o">.</span><span class="n">subpixel_localize</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">test_config</span>
        <span class="p">)</span>

        <span class="c1"># If debug_show_img_targets is turned on, generate the debug image</span>
        <span class="k">if</span> <span class="n">debug_show_img_targets</span><span class="p">:</span>
            <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets</span><span class="p">])</span>
            <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">img_centers</span><span class="p">)</span>
            <span class="n">visualization</span><span class="o">.</span><span class="n">show_image_locations</span><span class="p">(</span>
                <span class="n">img</span><span class="p">,</span> <span class="n">img_centers</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_Image_Center_Locations&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Using RANSAC, find the external calibration</span>
        <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">tvec_opt</span> <span class="o">=</span> <span class="n">external_calibrate</span><span class="o">.</span><span class="n">external_calibrate_RANSAC</span><span class="p">(</span>
            <span class="p">[</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">],</span>
            <span class="n">tgts</span><span class="p">,</span>
            <span class="n">img_targets</span><span class="p">,</span>
            <span class="n">vis_checker</span><span class="p">,</span>
            <span class="n">max_dist</span><span class="o">=</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
            <span class="n">match_thresh</span><span class="o">=</span><span class="n">match_thresh</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If debug_show_matches is turned on, generate the debug image</span>
        <span class="k">if</span> <span class="n">debug_show_matches</span><span class="p">:</span>
            <span class="n">visible_init_tgts</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
                <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">tvec_opt</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
            <span class="p">)</span>
            <span class="n">external_calibrate</span><span class="o">.</span><span class="n">match_targets</span><span class="p">(</span>
                <span class="n">rmat_opt</span><span class="p">,</span>
                <span class="n">tvec_opt</span><span class="p">,</span>
                <span class="n">cameraMatrix</span><span class="p">,</span>
                <span class="n">distCoeffs</span><span class="p">,</span>
                <span class="n">visible_init_tgts</span><span class="p">,</span>
                <span class="n">img_targets</span><span class="p">,</span>
                <span class="n">max_dist</span><span class="o">=</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
                <span class="n">debug</span><span class="o">=</span><span class="p">[</span><span class="n">img</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="kc">None</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># Transform from camera to tgts to tunnel -&gt; Get camera to tunnel transformation</span>
        <span class="n">rmat_camera_tunnel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat_opt</span><span class="p">,</span> <span class="n">rmat_tgts_tunnel</span><span class="p">)</span>
        <span class="n">tvec_camera_tunnel</span> <span class="o">=</span> <span class="n">tvec_opt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat_opt</span><span class="p">,</span> <span class="n">tvec_tgts_tunnel</span><span class="p">)</span>

        <span class="c1"># Package the camera calibration data</span>
        <span class="n">uPSP_cameraMatrix</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">convert_cv2_cm_to_uPSP_cm</span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">datum</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;uPSP_cameraMatrix&quot;</span><span class="p">:</span> <span class="n">uPSP_cameraMatrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;distCoeffs&quot;</span><span class="p">:</span> <span class="n">distCoeffs</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;rmat&quot;</span><span class="p">:</span> <span class="n">rmat_camera_tunnel</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;tvec&quot;</span><span class="p">:</span> <span class="n">tvec_camera_tunnel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;sensor_resolution&quot;</span><span class="p">:</span> <span class="n">sensor_resolution</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;sensor_size&quot;</span><span class="p">:</span> <span class="n">sensor_size</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="p">}</span>

        <span class="c1"># Export the calibration as a json file</span>
        <span class="n">cal_file</span> <span class="o">=</span> <span class="s2">&quot;camera&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ctc_dir</span><span class="p">,</span> <span class="n">cal_file</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<span class="c1"># TODO: need to implement use of rmat__cor_tgts__tgts_frame as an input</span>
<div class="viewcode-block" id="tunnel_transform"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.camera_tunnel_calibrate.html#upsp.cam_cal_utils.camera_tunnel_calibrate.tunnel_transform">[docs]</a><span class="k">def</span> <span class="nf">tunnel_transform</span><span class="p">(</span><span class="n">ALPHA</span><span class="p">,</span> <span class="n">BETA</span><span class="p">,</span> <span class="n">PHI</span><span class="p">,</span> <span class="n">STRUTZ</span><span class="p">,</span> <span class="n">tvec__cor_tgts__tgts_frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the transformation from the tunnel coordinate frame to the tgts frame</span>

<span class="sd">    Note: This is not necessarily to the tunnel origin, just some fixed point in the</span>
<span class="sd">    tunnel (fixed within a tunnel test). If `STRUTZ` = `STRUTZ_abs` then it will be the</span>
<span class="sd">    tunnel origin</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ALPHA : float</span>
<span class="sd">        Tunnel alpha in degrees</span>
<span class="sd">    BETA : float</span>
<span class="sd">        Tunnel beta in degrees</span>
<span class="sd">    PHI : float</span>
<span class="sd">        Tunnel phi in degrees</span>
<span class="sd">    STRUTZ : float</span>
<span class="sd">        STRUTZ location of the UPWT strut</span>
<span class="sd">    tvec__cor_tgts__tgts_frame : np.ndarray, shape (3, 1), dtype float</span>
<span class="sd">        Translation vector from the tunnel center of rotation to the tgts frame</span>
<span class="sd">        in the tgts frame. The tgts frame is a fixed distance from the tunnel point of</span>
<span class="sd">        rotation from the tgts frame&#39;s point of view, that translation vector is always</span>
<span class="sd">        along the x axis</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation_matrix : np.ndarray, shape (3, 3)</span>
<span class="sd">        Rotation matrix from tgts frame to tunnel frame</span>
<span class="sd">    tvec__tunnel_tgts__tunnel_frame : np.ndarray, shape (3, 1)</span>
<span class="sd">        Translation vector from tgts frame to tunnel frame</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the component rotation matrices</span>

    <span class="c1"># UPWT Tunnel Coordinates are RHS Aircraft Coordinates Pitched 180 degrees</span>
    <span class="c1"># See UPWT AIAA Coordinate Systems Training Manual For Details</span>

    <span class="c1"># Positive Alpha is Positive Pitch</span>
    <span class="n">pitch</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">rot</span><span class="p">(</span><span class="o">-</span><span class="n">ALPHA</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>

    <span class="c1"># Positive Beta is Negative Yaw</span>
    <span class="n">yaw</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">rot</span><span class="p">(</span><span class="o">-</span><span class="n">BETA</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)</span>

    <span class="c1"># Positive Phi is Positive Roll</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">rot</span><span class="p">(</span><span class="n">PHI</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="c1"># Combine into one rotation matrix</span>
    <span class="c1">#   Matrix Multiplication Order is [P][Y][R]</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">yaw</span><span class="p">,</span> <span class="n">roll</span><span class="p">))</span>

    <span class="c1"># We want the transformation from tunnel to tgts, so get the inverse</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">)</span>

    <span class="c1"># tvec__tgts_tunnel__tunnel_frame is the translation vector from the tunnel</span>
    <span class="c1">#   frame to the tgts frame, in the tunnel frame</span>
    <span class="c1"># I.e. Since the knuckle sleeve rotates relative to the tunnel, the model</span>
    <span class="c1">#   translation vector somewhere in the cone of allowable rotation. This</span>
    <span class="c1">#   calculates that translation. Also, the strutz can move up and down in</span>
    <span class="c1">#   the z axis, so that needs to be taken into account as well</span>
    <span class="n">tvec__knuckle_tgts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">tvec__cor_tgts__tgts_frame</span><span class="p">)</span>
    <span class="n">tvec__tunnel_tgts__tunnel_frame</span> <span class="o">=</span> <span class="n">tvec__knuckle_tgts</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">STRUTZ</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">tvec__tunnel_tgts__tunnel_frame</span></div>


<span class="c1"># TODO: This refers specifically to a model on the sting. We will need a function for</span>
<span class="c1">#   a floor mounted model, and ideally something in the test_config file to specify</span>
<span class="c1"># TODO: need to implement use of tunnel-cor_to_tgts_rmat from test_config</span>
<div class="viewcode-block" id="tf_camera_tgts_thru_tunnel"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.camera_tunnel_calibrate.html#upsp.cam_cal_utils.camera_tunnel_calibrate.tf_camera_tgts_thru_tunnel">[docs]</a><span class="k">def</span> <span class="nf">tf_camera_tgts_thru_tunnel</span><span class="p">(</span><span class="n">camera_tunnel_cal</span><span class="p">,</span> <span class="n">wtd</span><span class="p">,</span> <span class="n">test_config</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the transformation from the camera to the model (tgts frame)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    camera_cal : list</span>
<span class="sd">        camera calibration in the form::</span>

<span class="sd">            [rmat__camera_tunnel, tvec__camera_tunnel, cameraMatrix, distCoeffs]</span>
<span class="sd">    wtd : dict</span>
<span class="sd">        wind tunnel data as a dict with (at a minimum) the keys &#39;ALPHA&#39;, &#39;BETA&#39;, &#39;PHI&#39;,</span>
<span class="sd">        and &#39;STRUTZ&#39;. ALPHA, BETA, and PHI are tunnel angles in degrees. STRUTZ is the</span>
<span class="sd">        offset of the tunnel center of rotation for the z axis in inches</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        test configuration data as a dict with (at a minimum) the key</span>
<span class="sd">        &#39;tunnel-cor_to_tgts_tvec&#39; representing the translation vector from the tunnel</span>
<span class="sd">        center of rotation to the model frame</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat__camera_tgts : np.ndarray, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    tvec__camera_tgts : np.ndarray, shape (3, 1)</span>
<span class="sd">        Translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Turn the wind tunnel data into the transformation from tunnel to targets</span>
    <span class="n">wtd_transform</span> <span class="o">=</span> <span class="n">tunnel_transform</span><span class="p">(</span>
        <span class="n">wtd</span><span class="p">[</span><span class="s2">&quot;ALPHA&quot;</span><span class="p">],</span>
        <span class="n">wtd</span><span class="p">[</span><span class="s2">&quot;BETA&quot;</span><span class="p">],</span>
        <span class="n">wtd</span><span class="p">[</span><span class="s2">&quot;PHI&quot;</span><span class="p">],</span>
        <span class="n">wtd</span><span class="p">[</span><span class="s2">&quot;STRUTZ&quot;</span><span class="p">],</span>
        <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;tunnel-cor_to_tgts_tvec&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">rmat_tunnel_tgts</span><span class="p">,</span> <span class="n">tvec_tunnel_tgts</span> <span class="o">=</span> <span class="n">wtd_transform</span>

    <span class="c1"># Transformation from tgts frame to tunnel frame</span>
    <span class="n">rmat_tgts_tunnel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rmat_tunnel_tgts</span><span class="p">)</span>
    <span class="n">tvec_tgts_tunnel</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat_tgts_tunnel</span><span class="p">,</span> <span class="n">tvec_tunnel_tgts</span><span class="p">)</span>

    <span class="c1"># Decompose the camera calibration into its parts</span>
    <span class="p">(</span>
        <span class="n">rmat__camera_tunnel</span><span class="p">,</span>
        <span class="n">tvec__camera_tunnel</span><span class="p">,</span>
        <span class="n">cameraMatrix</span><span class="p">,</span>
        <span class="n">distCoeffs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">camera_tunnel_cal</span>

    <span class="c1"># Combine the transformations to get the transformation from `camera to tgts frame</span>
    <span class="n">rmat__camera_tgts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat__camera_tunnel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rmat_tgts_tunnel</span><span class="p">))</span>
    <span class="n">tvec__camera_tgts</span> <span class="o">=</span> <span class="n">tvec__camera_tunnel</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
        <span class="n">rmat__camera_tunnel</span><span class="p">,</span> <span class="n">tvec_tunnel_tgts</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rmat__camera_tgts</span><span class="p">,</span> <span class="n">tvec__camera_tgts</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, uPSP Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>