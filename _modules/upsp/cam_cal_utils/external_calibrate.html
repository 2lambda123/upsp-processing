
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>upsp.cam_cal_utils.external_calibrate &#8212; uPSP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">uPSP</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file-formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Third-Party Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../swdd.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../known-issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing this work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_apidoc/upsp.html"><code class="docutils literal notranslate"><span class="pre">upsp</span></code> Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for upsp.cam_cal_utils.external_calibrate</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">upsp.target_localization</span> <span class="kn">import</span> <span class="n">gaussian_fitting_methods</span>
<span class="kn">from</span> <span class="nn">upsp.cam_cal_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">visualization</span><span class="p">,</span>
    <span class="n">visibility</span><span class="p">,</span>
    <span class="n">camera_tunnel_calibrate</span><span class="p">,</span>
    <span class="n">photogrammetry</span><span class="p">,</span>
    <span class="n">img_utils</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">gauss_fit</span> <span class="o">=</span> <span class="n">gaussian_fitting_methods</span><span class="o">.</span><span class="n">gauss_fitter_func</span><span class="p">(</span><span class="s2">&quot;super&quot;</span><span class="p">)</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Debugs</span>
<span class="n">debug_raw_matches</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">debug_coarse_optimization</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">debug_refined_matches</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">debug_visible_projections</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">debug_refined_optimization</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">debug_show_localizations</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Other Functions</span>


<div class="viewcode-block" id="compare_poses"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.compare_poses">[docs]</a><span class="k">def</span> <span class="nf">compare_poses</span><span class="p">(</span><span class="n">pose0</span><span class="p">,</span> <span class="n">pose1</span><span class="p">,</span> <span class="n">more_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle and distance in which the two poses differ</span>

<span class="sd">    Any two rotation matrices are related by a single rotation of theta about a given</span>
<span class="sd">    axis. Any two translation vectors are related by an [X, Y, Z] translation vector.</span>
<span class="sd">    This function returns the angle between the two poses, as well as the distance</span>
<span class="sd">    formatted as [theta, dist] where theta is in degrees and dist is in the units of</span>
<span class="sd">    tvec. If `more_info` is True, [theta, axis, tvec_rel] is returned where axis is the</span>
<span class="sd">    axis of rotation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pose0, pose1 : tuple</span>
<span class="sd">        Pose to compare: ``(rmat, tvec)``, where ``rmat`` is the rotation matrix from</span>
<span class="sd">        camera to object (:class:`numpy.ndarray` with shape (3, 3)) and ``tvec`` is the</span>
<span class="sd">        translation vector from camera to object (:class:`numpy.ndarray` with shape (3,</span>
<span class="sd">        1)).</span>
<span class="sd">    more_info : bool, optional</span>
<span class="sd">        Changes the return value. Function returns (theta, distance) if `more_info` is</span>
<span class="sd">        False, function returns (rvec, tvec) if `more_info` is True</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        If `more_info` is False, returns ``(theta, distance)``. If `more_info` is True,</span>
<span class="sd">        return is ``(rvec, tvec)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Unpack the rmats and tvecs</span>
    <span class="n">rmat0</span><span class="p">,</span> <span class="n">tvec0</span> <span class="o">=</span> <span class="n">pose0</span>
    <span class="n">rmat1</span><span class="p">,</span> <span class="n">tvec1</span> <span class="o">=</span> <span class="n">pose1</span>

    <span class="c1"># Get relative transformations</span>
    <span class="n">rmat_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat1</span><span class="p">,</span> <span class="n">rmat0</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">tvec_rel</span> <span class="o">=</span> <span class="n">tvec1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat_rel</span><span class="p">,</span> <span class="n">tvec0</span><span class="p">)</span>

    <span class="c1"># Get the axis and theta for rmat_rel</span>
    <span class="n">rvec_rel</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rmat_rel</span><span class="p">)</span>

    <span class="c1"># OpenCV&#39;s Rodrigues vector is a compact representation where theta is the magnitude</span>
    <span class="c1">#   of the vector (convert from radians to degrees)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rvec_rel</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="c1"># If more_info was not requested, return only the angle and distance</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">more_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tvec_rel</span><span class="p">))</span>

    <span class="c1"># If more_info was requested, return the Rodrigues vector and full tvec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">rvec_rel</span><span class="p">,</span> <span class="n">tvec_rel</span><span class="p">)</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Calibration Functions</span>


<span class="c1"># TODO: make this return a num_matches, all targets, and all unique img_targets just</span>
<span class="c1">#   like to other targets functions</span>
<div class="viewcode-block" id="subpixel_localize"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.subpixel_localize">[docs]</a><span class="k">def</span> <span class="nf">subpixel_localize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">test_config</span><span class="p">,</span> <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the sub-pixel localized position of the image targets</span>

<span class="sd">    Find the location of the image target centers with sub-pixel accuracy. This method</span>
<span class="sd">    filters common bad localization solutions. I.e The localized position is too far</span>
<span class="sd">    initial guess to make sense, invalid optimizer solution (None flag), outside the</span>
<span class="sd">    cropped region or outside the image</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (h, w)</span>
<span class="sd">        Numpy 2D array of the image</span>
<span class="sd">    tgts : list</span>
<span class="sd">        Matched 3D targets. Each target should be a dict. The only strict requirement</span>
<span class="sd">        set by this function is ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, keys &#39;center&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. &#39;center&#39; has a value of the image target center location</span>
<span class="sd">        (tuple/np.ndarray of length 2 of floats) and &#39;target_type&#39; has the key of the</span>
<span class="sd">        type of target (string). ``img_targets[i]`` is associated with ``tgts[i]``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for each target type in</span>
<span class="sd">        `targets` and `img_targets`.  The key is `target_type` + &#39;_pad&#39;. This is the</span>
<span class="sd">        padding around the img target center location to use to sub-pixel localize</span>
<span class="sd">    max_localize_delta : float, optional</span>
<span class="sd">        The maximum allowable distance that subpixel_localize can change the</span>
<span class="sd">        `img_target` position. If None, the max allowable distance will be set to the</span>
<span class="sd">        padding distance minus 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    targets : list</span>
<span class="sd">        Target positions (`tgts`) that have not been filtered out.</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Refined (sub-pixel localized) target positions in the image.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``targets[i]`` is associated with ``img_targets[i]``. Return lists may not be the</span>
<span class="sd">    same length as input `tgts` and/or `img_targets` inputs (some</span>
<span class="sd">    `targets`/`img_targets` from the input may be rejected and thus are not included in</span>
<span class="sd">    the output)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_localize_delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_dist</span> <span class="o">=</span> <span class="n">max_localize_delta</span>

    <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">img_targets_refined</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img_targets</span><span class="p">):</span>
        <span class="c1"># Integer of center pixel</span>
        <span class="n">center_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
            <span class="p">(</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">target_pad</span> <span class="o">=</span> <span class="n">test_config</span><span class="p">[</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_pad&quot;</span><span class="p">]</span>

        <span class="c1"># cropped region around target (x1, y1), (x2, y2)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">center_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_pad</span><span class="p">,</span> <span class="n">center_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_pad</span><span class="p">],</span>
            <span class="p">[</span><span class="n">center_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">target_pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">center_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">target_pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="c1"># If bbox goes out of bounds of the image, ignore it</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_targets_refined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">],</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Cropped image around target</span>
        <span class="n">img_cropped</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Perform the sub-pixel localization</span>
        <span class="n">gauss_center</span> <span class="o">=</span> <span class="n">gauss_fit</span><span class="p">(</span>
            <span class="n">img_cropped</span><span class="p">,</span>
            <span class="n">target_type</span><span class="o">=</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">],</span>
            <span class="n">center</span><span class="o">=</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">],</span>
            <span class="n">img_offset</span><span class="o">=</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If the optimizer failed, continue</span>
        <span class="k">if</span> <span class="n">gauss_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_targets_refined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Create a new img_target with the updated center location</span>
        <span class="n">img_target_refined</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>
        <span class="n">img_target_refined</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gauss_center</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">gauss_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_target_refined</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">gauss_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_target_refined</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># A distance of target_pad - 1 would imply the center is on a pixel in the edge</span>
        <span class="c1">#   of the crop. And since the taret is larger than 1 pixel, by definition this</span>
        <span class="c1">#   is a bad localization. Not even to mention it is likely bad since it is so</span>
        <span class="c1">#   far off from the expected position. We do target_pad - 2 to add a margin of</span>
        <span class="c1">#   safety</span>
        <span class="k">if</span> <span class="n">max_localize_delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_dist</span> <span class="o">=</span> <span class="n">target_pad</span> <span class="o">-</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">filter_dist</span><span class="p">:</span>
            <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_targets_refined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">debug_show_localizations</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_cropped</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">gauss_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">gauss_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">center_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">center_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">img_targets_refined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target_refined</span><span class="p">)</span>

    <span class="c1"># Remove the targets that had a bad localization</span>
    <span class="n">tgts_loc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_loc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">img_target</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets_refined</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_of_bounds</span><span class="p">:</span>
            <span class="n">tgts_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">img_targets_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_loc</span><span class="p">,</span> <span class="n">img_targets_loc</span></div>


<span class="c1"># TODO: make this return a num_matches, all targets, and all unique img_targets just</span>
<span class="c1">#   like to other targets functions</span>
<div class="viewcode-block" id="filter_partially_occluded"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_partially_occluded">[docs]</a><span class="k">def</span> <span class="nf">filter_partially_occluded</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">focal_length</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">,</span> <span class="n">test_config</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks corners of cropped area used for sub-pixel localization for occlusion</span>

<span class="sd">    If the corners of the crop used for sub-pixel localization jumps surfaces, then the</span>
<span class="sd">    target is likely partially occluded. This most commonly occurs when a booster</span>
<span class="sd">    partially occludes a target on the core of a launch vehicle</span>

<span class="sd">    To get the 3D positions of corners of the cropped area, start at the target tvec.</span>
<span class="sd">    Approximate the physical distance (in inches) of the cropped area (which is</span>
<span class="sd">    done in pixels) using the focal length and distance from camera to model. Take</span>
<span class="sd">    steps along the camera image plane to get to the approximate corner locations in 3D.</span>

<span class="sd">    With the corner locations, ensure that they are not inside the model (since the</span>
<span class="sd">    model is curved the steps along the image plane may put the corners slightly inside</span>
<span class="sd">    the model. Then check for occlusions. If the corner is occluded, the target is</span>
<span class="sd">    deemed partially occluded. If none of the corners are occluded, the target is deemed</span>
<span class="sd">    not occluded (but is still potentially partially occluded). Only the corners are</span>
<span class="sd">    checked to reduce computation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    focal_length : float</span>
<span class="sd">        Focal length of the camera. Most easily accessible from a ``cameraMatrix[0][0]``</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;,</span>
<span class="sd">        &#39;target_type&#39;, &#39;norm&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the</span>
<span class="sd">        position of the target relative to the model origin for its associated value.</span>
<span class="sd">        &#39;norm&#39; has a :class:`numpy.ndarray` (3, 1) representing the normal vector of the</span>
<span class="sd">        target relative to the model origin for its associated value. &#39;target_type&#39; has</span>
<span class="sd">        a string representing the type of target (most commonly &#39;dot&#39;) for its</span>
<span class="sd">        associated value. ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Image targets. Each image target should be a dict, but this function does not</span>
<span class="sd">        set any strict requirements other than that ``img_targets[i]`` is associated</span>
<span class="sd">        with ``tgts[i]``</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processign parameters with, at a minimum, a key for each target type of the</span>
<span class="sd">        targets in `tgts` and `img_targets`. They key is `target_type` + &#39;_pad&#39;. This is</span>
<span class="sd">        the padding around the img target center location to use to sub-pixel localize</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered : list</span>
<span class="sd">        Target positions (`tgts`) that have not been filtered out</span>
<span class="sd">    img_targets_filtered : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the direction for the u and v of pixel space</span>
    <span class="n">rmat_inv</span><span class="p">,</span> <span class="n">tvec_inv</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">invTransform</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">)</span>

    <span class="c1"># Check each target for partial occlusions</span>
    <span class="n">tgts_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">):</span>
        <span class="c1"># Get the scale factor</span>
        <span class="n">obj_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tvec</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">])</span>

        <span class="c1"># For the scale factor, we use the similar triangles of the object distance by</span>
        <span class="c1">#   actual distance (in) vs focal length by pixel distance (px)</span>
        <span class="c1"># The scale factor is the object distance divided by the focal length, times the</span>
        <span class="c1">#   pixel distance. We add one to the pad distance for a margin of safety</span>
        <span class="n">step_sz</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">obj_dist</span> <span class="o">*</span> <span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_pad&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">focal_length</span>
        <span class="p">)</span>

        <span class="c1"># Get the step vector for u and v for the corners</span>
        <span class="c1"># Get the u and v steps</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">step_sz</span> <span class="o">*</span> <span class="n">rmat_inv</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Package the corners. We have 1 corner for steps in the given directions</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="n">corners</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;tvec&quot;</span><span class="p">:</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]})</span>

        <span class="c1"># Check for occlusions. Each corner has a boolean and an occlusion position</span>
        <span class="n">occlusions</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_occlusions_targets</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">vis_checker</span>
        <span class="p">)</span>

        <span class="c1"># Check that all corners are visible</span>
        <span class="n">are_all_corners_visible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">corner</span><span class="p">,</span> <span class="n">occlusion</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">occlusions</span><span class="p">):</span>
            <span class="c1"># If there was no occlusion, continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">occlusion</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># If there was an occlusion, check the distance from the occlusion to corner</span>
            <span class="c1"># If that distance is less than sqrt(2) * step_sz (since we step in both</span>
            <span class="c1">#   x and y) it is possible that the corner is inside the model so it is</span>
            <span class="c1">#   unfairly occluded.</span>
            <span class="c1"># If the distance is greater this corner is just occluded, no questions</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">occlusion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">corner</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">step_sz</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">are_all_corners_visible</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

            <span class="c1"># To fairly check this corner, bump it to the occluded location</span>
            <span class="n">bumped_corner</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">corner</span><span class="p">)</span>
            <span class="n">bumped_corner</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">occlusion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check this bumped corner for occlusion</span>
            <span class="n">bumped_occlusion</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_occlusions_targets</span><span class="p">(</span>
                <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="p">[</span><span class="n">bumped_corner</span><span class="p">],</span> <span class="n">vis_checker</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If there is still an occlusion, this corner is likely occluded</span>
            <span class="c1"># There is a chance that the distance between the bumped occlusion and</span>
            <span class="c1">#   the original corner is still less than step_sz * np.sqrt(2). However</span>
            <span class="c1">#   the occurrence seems small and not worthy of further checks.</span>
            <span class="c1"># This is a potential TODO to set up as a while loop</span>
            <span class="k">if</span> <span class="n">bumped_occlusion</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">are_all_corners_visible</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="c1"># If all corners passed the visibility check, this corner is fine and we can</span>
        <span class="c1">#   move onto the next corner</span>
        <span class="k">if</span> <span class="n">are_all_corners_visible</span><span class="p">:</span>
            <span class="n">tgts_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">img_targets_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span></div>


<div class="viewcode-block" id="filter_min_dist"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_min_dist">[docs]</a><span class="k">def</span> <span class="nf">filter_min_dist</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters the targets and image target that are too close together in the image</span>

<span class="sd">    If the image locations of any two targets are below the min_dist threshold, remove</span>
<span class="sd">    both targets from the set of matched targets. This is to avoid ambiguity in target</span>
<span class="sd">    matching.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target should be a dict. The only strict requirement set by</span>
<span class="sd">        this function is ``tgts[i]`` is associated with ``img_targets[i]`` for i from 0</span>
<span class="sd">        to `num_matches`</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, the key &#39;center&#39; which has a</span>
<span class="sd">        value of the image target center location (tuple/np.ndarray of floats).</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]`` for i from 0 to `num_matches`</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>
<span class="sd">    min_dist : float, optional</span>
<span class="sd">        The minimum distance between two image targets. Any image targets closer than</span>
<span class="sd">        this distance are filtered out.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered : list</span>
<span class="sd">        Target positions (`tgts`) that have been filtered so that their image locations</span>
<span class="sd">        are separated by a distance larger than min_dist.</span>
<span class="sd">    img_targets_filtered : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    num_matches_filtered : int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_filtered[i]`` is associated with ``img_targets_filtered[i]`` for i from 0 to</span>
<span class="sd">    `num_matches_filtered`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the image targets that are too close together</span>
    <span class="n">supressed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">supressed</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="n">supressed</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Calculate the distance between point i and j</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_targets</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_targets</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># If the distance is below the given threshold, add both i and j to the list</span>
            <span class="c1">#   of supressed points</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                <span class="n">supressed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">supressed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">continue</span>

    <span class="c1"># First add targets that pass the min_dist check</span>
    <span class="n">tgts_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">supressed</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">tgts_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">img_targets_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># The number of matches is the number after the filter</span>
    <span class="n">num_matches_filtered</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts_filtered</span><span class="p">)</span>

    <span class="c1"># Then add the remaining targets and image targets</span>
    <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_filtered</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span><span class="p">,</span> <span class="n">num_matches_filtered</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_bifilter"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_bifilter">[docs]</a><span class="k">def</span> <span class="nf">filter_bifilter</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">,</span> <span class="n">max_dist</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters the targets and image target for ambiguity</span>

<span class="sd">    Check that only 1 img target is within a radius of max_dist from every projected</span>
<span class="sd">    target location. If more than 1 img target is near a target, do not use that target</span>

<span class="sd">    Check that only 1 projected target location is within a radius of max_dist from</span>
<span class="sd">    every img target. If more than 1 projected target location is near an img target,</span>
<span class="sd">    do not use that img target</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the</span>
<span class="sd">        position of the target relative to the model origin for its associated value.</span>
<span class="sd">        &#39;target_type&#39; has a string representing the type of target (most commonly &#39;dot&#39;)</span>
<span class="sd">        for its associated value. ``tgts[i]`` is associated with ``img_targets[i]`` for</span>
<span class="sd">        i from 0 to `num_matches`</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, the key &#39;center&#39; which has a</span>
<span class="sd">        value of is the image target center location (tuple/np.ndarray of floats).</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]`` for i from 0 to `num_matches`</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>
<span class="sd">    max_dist : float</span>
<span class="sd">        The maximum distance between two image targets. Any image targets farther than</span>
<span class="sd">        this distance are filtered out.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_bifilter : list</span>
<span class="sd">        Target positions (`tgts`) that have been bifiltered.</span>
<span class="sd">    img_targets_bifilter : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    num_matches_bifilter : int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_matched_bifilter[i]`` is associated with ``img_targets_bifilter[i]`` for i</span>
<span class="sd">    from 0 to `num_matches_bifilter`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Project the points into the image</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span>
    <span class="p">)</span>

    <span class="c1"># Check that all targets have at most 1 img target nearby</span>
    <span class="n">tgts_matched_temp</span><span class="p">,</span> <span class="n">img_targets_temp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">num_matches_temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="n">tgt_proj</span> <span class="o">=</span> <span class="n">tgt_projs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">bifilter_key</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">img_tgt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img_targets</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_tgt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">])</span>

            <span class="c1"># If the distance is less than max_dist, this target fails the bifilter</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_dist</span><span class="p">:</span>
                <span class="n">bifilter_key</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">bifilter_key</span><span class="p">:</span>
            <span class="n">tgts_matched_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">img_targets_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">num_matches_temp</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">tgts_matched_temp</span><span class="p">,</span> <span class="n">img_targets_temp</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_matched_temp</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_temp</span>
    <span class="p">)</span>

    <span class="c1"># Project the points into the image</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts_matched_temp</span>
    <span class="p">)</span>

    <span class="c1"># Check that all img targets have at most 1 target nearby</span>
    <span class="n">tgts_bifilter</span><span class="p">,</span> <span class="n">img_targets_bifilter</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">num_matches_bifilter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches_temp</span><span class="p">):</span>
        <span class="n">img_tgt</span> <span class="o">=</span> <span class="n">img_targets_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">bifilter_key</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tgt_projs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_tgt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># If the distance is less than max_dist, this target fails the bifilter</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_dist</span><span class="p">:</span>
                <span class="n">bifilter_key</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">bifilter_key</span><span class="p">:</span>
            <span class="n">tgts_bifilter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgts_matched_temp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">img_targets_bifilter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_targets_temp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">num_matches_bifilter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">tgts_bifilter</span><span class="p">,</span> <span class="n">img_targets_bifilter</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_bifilter</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_bifilter</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_bifilter</span><span class="p">,</span> <span class="n">img_targets_bifilter</span><span class="p">,</span> <span class="n">num_matches_bifilter</span></div>


<div class="viewcode-block" id="filter_one2one"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_one2one">[docs]</a><span class="k">def</span> <span class="nf">filter_one2one</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters the targets and image target to ensure matches are one-to-one</span>

<span class="sd">    Ensures that each target is matched with at most 1 img target, and that each img</span>
<span class="sd">    target is matched with at most 1 target. Remove anything that is not 1:1 as stated</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target should be a dict. The only strict requirement set by</span>
<span class="sd">        this function is ``tgts[i]`` is associated with ``img_targets[i]`` for i from 0</span>
<span class="sd">        to `num_matches`</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Image targets. Each image target should be a dict, but this function does not</span>
<span class="sd">        set any strict requirements other than that ``img_targets[i]`` is associated</span>
<span class="sd">        with ``tgts[i]`` for i from 0 to `num_matches`</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered_one2one : list</span>
<span class="sd">        Target positions (`tgts`) that have been filtered for pairs that are one-to-one.</span>
<span class="sd">    img_targets_one2one : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    num_matches_one2one : int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_one2one[i]`` is associated with ``img_targets_one2one[i]`` for i from 0 to</span>
<span class="sd">    `num_matches_one2one`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that each img_target is used at most once</span>
    <span class="n">tgts_filtered_temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_matches_temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="c1"># Unpack the target and match</span>
        <span class="n">tgt</span><span class="p">,</span> <span class="n">match</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create a copy of the all matching points minus the current</span>
        <span class="n">img_targets_subset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_targets</span><span class="p">[:</span><span class="n">num_matches</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">img_targets_subset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Convert the numpy arrays to lists for comparisons</span>
        <span class="n">match_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
        <span class="n">match_temp</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_temp</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets_subset</span><span class="p">)):</span>
            <span class="n">img_targets_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">img_targets_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># If match is not in the list, there is a 1:1 matching and it can be included</span>
        <span class="k">if</span> <span class="n">match_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">img_targets_subset</span><span class="p">:</span>
            <span class="n">tgts_filtered_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">img_targets_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
            <span class="n">num_matches_temp</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">img_targets_subset</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># deleteme</span>

    <span class="c1"># Check that each img_target is used at most once</span>
    <span class="n">tgts_filtered_one2one</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_one2one</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_matches_one2one</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches_temp</span><span class="p">):</span>
        <span class="c1"># Unpack the target and match</span>
        <span class="n">tgt</span><span class="p">,</span> <span class="n">match</span> <span class="o">=</span> <span class="n">tgts_filtered_temp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">img_targets_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create a copy of the all matching points minus the current</span>
        <span class="n">tgts_subset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgts_filtered_temp</span><span class="p">[:</span><span class="n">num_matches_temp</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">tgts_subset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Convert the numpy arrays to lists for comparisons</span>
        <span class="n">tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
        <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts_subset</span><span class="p">)):</span>
            <span class="n">tgts_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgts_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgts_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgts_subset</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># If match is not in the list, there is a 1:1 matching and it can be included</span>
        <span class="k">if</span> <span class="n">tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_subset</span><span class="p">:</span>
            <span class="n">tgts_filtered_one2one</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">img_targets_one2one</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
            <span class="n">num_matches_one2one</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">tgts_filtered_one2one</span><span class="p">,</span> <span class="n">img_targets_one2one</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_filtered_one2one</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_one2one</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered_one2one</span><span class="p">,</span> <span class="n">img_targets_one2one</span><span class="p">,</span> <span class="n">num_matches_one2one</span></div>


<div class="viewcode-block" id="filter_max_dist"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_max_dist">[docs]</a><span class="k">def</span> <span class="nf">filter_max_dist</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">,</span> <span class="n">max_dist</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters the targets and image target to pairs are not very far apart</span>

<span class="sd">    Any match where the distance between the projected target pixel position and the</span>
<span class="sd">    img target center is greater than max_dist is removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. &#39;tvec&#39; has a :class:`np.ndarray` (3, 1) representing the position</span>
<span class="sd">        of the target relative to the model origin for its associated value.</span>
<span class="sd">        &#39;target_type&#39; has a string representing the type of target (most commonly &#39;dot&#39;)</span>
<span class="sd">        for its associated value. ``tgts[i]`` is associated with ``img_targets[i]`` for</span>
<span class="sd">        i from 0 to `num_matches`.</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, the key &#39;center&#39; which has a</span>
<span class="sd">        value of is the image target center location (tuple/np.ndarray of floats).</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]`` for i from 0 to num_matches</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>
<span class="sd">    max_dist : float</span>
<span class="sd">        The maximum matching distance between a 3D target&#39;s project and an image targets</span>
<span class="sd">        center. Pairs with matching distance greater this distance are filtered out.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered : list</span>
<span class="sd">        Target positions (`tgts`) that have been filtered such that the matching</span>
<span class="sd">        distance is less than max_dist.</span>
<span class="sd">    img_targets_filtered : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    num_matches_filtered : int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_filtered[i]`` is associated with ``img_targets_filtered[i]`` for i from</span>
<span class="sd">    0 to `num_matches_filtered`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Project the points into the image</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span>
    <span class="p">)</span>

    <span class="c1"># First, add the targets that are within max_dist from their image targets</span>
    <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="n">tgt_proj</span><span class="p">,</span> <span class="n">img_target</span> <span class="o">=</span> <span class="n">tgt_projs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_dist</span><span class="p">:</span>
            <span class="n">tgts_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">img_targets_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">num_matches_filtered</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts_filtered</span><span class="p">)</span>

    <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_filtered</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span><span class="p">,</span> <span class="n">num_matches_filtered</span></div>


<div class="viewcode-block" id="filter_nones"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_nones">[docs]</a><span class="k">def</span> <span class="nf">filter_nones</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filters the targets and image target to remove None objects</span>

<span class="sd">    :func:`match_obj_and_img_pts` matches each target to the closest img target.</span>
<span class="sd">    Therefore, it is possible that not every img target will have a match. Additionally,</span>
<span class="sd">    if ``max_dist`` is given to :func:`match_obj_and_img_pts`, it is possible that not</span>
<span class="sd">    every target will have a match. :func:`match_obj_and_img_pts` solves this by</span>
<span class="sd">    matching unmatched items to None.</span>

<span class="sd">    That causes something to fail, so this function reformats that output. Instead of</span>
<span class="sd">    using Nones, this function reorders the list of targets to the first n target have</span>
<span class="sd">    a match, and correspond to the first n items of the img targets list. n is</span>
<span class="sd">    additionally given as num_matches</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target should be a dict. The only strict requirement set by</span>
<span class="sd">        this function is ``tgts[i]`` is associated with ``img_targets[i]`` for i from 0</span>
<span class="sd">        to `num_matches`</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Image targets. Each image target should be a dict, but this function does not</span>
<span class="sd">        set any strict requirements other than that ``img_targets[i]`` is associated</span>
<span class="sd">        with ``tgts[i]``</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered : list</span>
<span class="sd">        Target positions (`tgts`) that have been filtered to remove None values.</span>
<span class="sd">    img_targets_filtered : list</span>
<span class="sd">        Target positions in the image.</span>
<span class="sd">    num_matches_filtered : int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_filtered[i]`` is associated with ``img_targets_filtered[i]`` for i from</span>
<span class="sd">    0 to `num_matches_filtered`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialized filtered lists and a count</span>
    <span class="n">tgts_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_matches_filtered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># First add the matches where the img_targets are not None</span>
    <span class="c1">#   Increment the count of matched targets</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">):</span>
        <span class="n">tgt</span><span class="p">,</span> <span class="n">img_target</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">img_targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">img_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tgts_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">img_targets_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>
            <span class="n">num_matches_filtered</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_filtered</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span><span class="p">,</span> <span class="n">num_matches_filtered</span></div>


<div class="viewcode-block" id="filter_matches"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.filter_matches">[docs]</a><span class="k">def</span> <span class="nf">filter_matches</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span>
    <span class="n">tvec</span><span class="p">,</span>
    <span class="n">cameraMatrix</span><span class="p">,</span>
    <span class="n">distCoeffs</span><span class="p">,</span>
    <span class="n">tgts</span><span class="p">,</span>
    <span class="n">img_targets</span><span class="p">,</span>
    <span class="n">num_matches</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to run multiple filtering functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target is a dict that has, at a minimum, the keys &#39;tvec&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the</span>
<span class="sd">        position of the target relative to the model origin for its associated value.</span>
<span class="sd">        &#39;target_type&#39; has a string representing the type of target (most commonly &#39;dot&#39;)</span>
<span class="sd">        for its associated value. ``tgts[i]`` is associated with ``img_targets[i]`` for</span>
<span class="sd">        i from 0 to `num_matches`</span>
<span class="sd">    img_targets : list</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, the key &#39;center&#39; which has a</span>
<span class="sd">        value of is the image target center location (tuple/np.ndarray of floats).</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]`` for i from 0 to `num_matches`</span>
<span class="sd">    num_matches : int</span>
<span class="sd">        An integer of the number of matches. Must be less than or equal to</span>
<span class="sd">        ``min(len(tgts), len(img_targets))``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;.</span>
<span class="sd">        &#39;min_dist&#39; is the minimum distance between two image targets. &#39;max_dist&#39; is the</span>
<span class="sd">        maximum allowable distance between an image target and the projection of a 3D</span>
<span class="sd">        target</span>
<span class="sd">    debug : tuple, optional</span>
<span class="sd">        tuple of length 2. First item is the image to use as the background. Second item</span>
<span class="sd">        is the name of the debug image</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_filtered: list</span>
<span class="sd">        Targets filtered to remove None values, matches greater than the maximum</span>
<span class="sd">        matching distance, matches that are not one-to-one, matches that do not pass a</span>
<span class="sd">        &quot;bifilter&quot; test, and matches that have image locations that are too close</span>
<span class="sd">        together</span>
<span class="sd">    img_targets_filtered: list</span>
<span class="sd">        Associated image locations of `tgts_filtered`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the targets aren&#39;t empty, perform all the filtering operations</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num_matches</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">tgts_a</span><span class="p">,</span> <span class="n">img_targets_a</span><span class="p">,</span> <span class="n">num_matches_a</span> <span class="o">=</span> <span class="n">filter_nones</span><span class="p">(</span>
            <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="p">)</span>

        <span class="n">tgts_b</span><span class="p">,</span> <span class="n">img_targets_b</span><span class="p">,</span> <span class="n">num_matches_b</span> <span class="o">=</span> <span class="n">filter_max_dist</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span>
            <span class="n">tvec</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_a</span><span class="p">,</span>
            <span class="n">img_targets_a</span><span class="p">,</span>
            <span class="n">num_matches_a</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">tgts_c</span><span class="p">,</span> <span class="n">img_targets_c</span><span class="p">,</span> <span class="n">num_matches_c</span> <span class="o">=</span> <span class="n">filter_one2one</span><span class="p">(</span>
            <span class="n">tgts_b</span><span class="p">,</span> <span class="n">img_targets_b</span><span class="p">,</span> <span class="n">num_matches_b</span>
        <span class="p">)</span>

        <span class="n">tgts_d</span><span class="p">,</span> <span class="n">img_targets_d</span><span class="p">,</span> <span class="n">num_matches_d</span> <span class="o">=</span> <span class="n">filter_bifilter</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span>
            <span class="n">tvec</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_c</span><span class="p">,</span>
            <span class="n">img_targets_c</span><span class="p">,</span>
            <span class="n">num_matches_c</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">tgts_e</span><span class="p">,</span> <span class="n">img_targets_e</span><span class="p">,</span> <span class="n">num_matches_e</span> <span class="o">=</span> <span class="n">filter_min_dist</span><span class="p">(</span>
            <span class="n">tgts_d</span><span class="p">,</span> <span class="n">img_targets_d</span><span class="p">,</span> <span class="n">num_matches_d</span><span class="p">,</span> <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;min_dist&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">tgts_filtered</span> <span class="o">=</span> <span class="n">tgts_e</span><span class="p">[:</span><span class="n">num_matches_e</span><span class="p">]</span>
        <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">img_targets_e</span><span class="p">[:</span><span class="n">num_matches_e</span><span class="p">]</span>

    <span class="c1"># If the targets are empty, populate the stages of filtering with the initialized</span>
    <span class="c1">#   values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tgts_a</span><span class="p">,</span> <span class="n">img_targets_a</span><span class="p">,</span> <span class="n">num_matches_a</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="n">tgts_b</span><span class="p">,</span> <span class="n">img_targets_b</span><span class="p">,</span> <span class="n">num_matches_b</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="n">tgts_c</span><span class="p">,</span> <span class="n">img_targets_c</span><span class="p">,</span> <span class="n">num_matches_c</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="n">tgts_d</span><span class="p">,</span> <span class="n">img_targets_d</span><span class="p">,</span> <span class="n">num_matches_d</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="n">tgts_e</span><span class="p">,</span> <span class="n">img_targets_e</span><span class="p">,</span> <span class="n">num_matches_e</span> <span class="o">=</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span>
        <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># If the debug input is not None (default), create an image of the tgts and</span>
    <span class="c1">#   img_targets at each stage of the filtering operation</span>
    <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tgts_img_targets_num_matches</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">],</span>
            <span class="p">[</span><span class="n">tgts_a</span><span class="p">,</span> <span class="n">img_targets_a</span><span class="p">,</span> <span class="n">num_matches_a</span><span class="p">],</span>
            <span class="p">[</span><span class="n">tgts_b</span><span class="p">,</span> <span class="n">img_targets_b</span><span class="p">,</span> <span class="n">num_matches_b</span><span class="p">],</span>
            <span class="p">[</span><span class="n">tgts_c</span><span class="p">,</span> <span class="n">img_targets_c</span><span class="p">,</span> <span class="n">num_matches_c</span><span class="p">],</span>
            <span class="p">[</span><span class="n">tgts_d</span><span class="p">,</span> <span class="n">img_targets_d</span><span class="p">,</span> <span class="n">num_matches_d</span><span class="p">],</span>
            <span class="p">[</span><span class="n">tgts_e</span><span class="p">,</span> <span class="n">img_targets_e</span><span class="p">,</span> <span class="n">num_matches_e</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tgts_img_targets_num_matches</span><span class="p">):</span>
            <span class="n">tgts_temp</span><span class="p">,</span> <span class="n">img_targets_temp</span><span class="p">,</span> <span class="n">num_matches_temp</span> <span class="o">=</span> <span class="n">data</span>

            <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
                <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts_temp</span>
            <span class="p">)</span>

            <span class="n">proj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">])</span>
            <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets_temp</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">suffix</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;Original_match&quot;</span><span class="p">,</span>
                <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;filtered_a&quot;</span><span class="p">,</span>
                <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;filtered_b&quot;</span><span class="p">,</span>
                <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;filtered_c&quot;</span><span class="p">,</span>
                <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;filtered_d&quot;</span><span class="p">,</span>
                <span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;filtered_e&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">debug</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">suffix</span>

            <span class="n">visualization</span><span class="o">.</span><span class="n">show_projection_matching</span><span class="p">(</span>
                <span class="n">debug</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">proj_pts</span><span class="p">,</span>
                <span class="n">img_centers</span><span class="p">,</span>
                <span class="n">num_matches</span><span class="o">=</span><span class="n">num_matches_temp</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">bonus_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span></div>


<div class="viewcode-block" id="match_obj_and_img_pts"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.match_obj_and_img_pts">[docs]</a><span class="k">def</span> <span class="nf">match_obj_and_img_pts</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches 3D targets to the image targets</span>

<span class="sd">    Projects the 3D targets into the image, then finds the closest image target. If the</span>
<span class="sd">    closest image target is less than max_dist pixels away, it is matched. If it is</span>
<span class="sd">    farther than `max_dist` pixels, it is matched to None. This matching scheme does not</span>
<span class="sd">    ensure matches are one-to-one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3,), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (5,), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : np.ndarray, shape (n, 3)</span>
<span class="sd">        List of 3D targets.</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        Matched image target information. Each dict has, at a minimum, keys &#39;center&#39;,</span>
<span class="sd">        and &#39;target_type&#39;. &#39;center&#39; has a value of the image target center location</span>
<span class="sd">        (tuple/np.ndarray of length 2 of floats) and &#39;target_type&#39; has the key of the</span>
<span class="sd">        type of target (string). ``img_targets[i]`` is associated with ``tgts[i]``</span>
<span class="sd">    max_dist : float</span>
<span class="sd">        The maximum matching distance between a 3D target&#39;s project and an image targets</span>
<span class="sd">        center. Pairs with matching distance greater this distance are filtered out.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -----------</span>
<span class="sd">    matching_img_targets : list</span>
<span class="sd">        List of the items from the `img_targets` input such that</span>
<span class="sd">        ``matching_img_targets[i]`` is the closest image target to the projected</span>
<span class="sd">        position of ``tgts[i]``. If the closest image target is farther than `max_dist`,</span>
<span class="sd">        ``matching_img_targets[i]`` is None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Project the points into the image</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span>
    <span class="p">)</span>

    <span class="c1"># For each target, find the matching image point of the same type</span>
    <span class="c1"># Matches are assumed to be the closest point</span>
    <span class="n">matching_img_targets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">match_dist</span> <span class="o">=</span> <span class="n">max_dist</span>
        <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets</span><span class="p">:</span>
            <span class="c1"># Check that the target types match</span>
            <span class="k">if</span> <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Calculate the distance</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># If the distance is over the distance threshold and less than current</span>
            <span class="c1">#   lowest distance, make this the new best match</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">match_dist</span><span class="p">:</span>
                <span class="n">match_dist</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

        <span class="n">matching_img_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

    <span class="c1"># Since the target ordering is not changes, we can return the visibles and</span>
    <span class="c1">#   projected as was given</span>
    <span class="k">return</span> <span class="n">matching_img_targets</span></div>


<div class="viewcode-block" id="match_targets"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.match_targets">[docs]</a><span class="k">def</span> <span class="nf">match_targets</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches each target to the closest img target</span>

<span class="sd">    If `max_dist` is given, distance between target and img target must be less than</span>
<span class="sd">    max_dist. By default this value is infinite, so any match is valid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list</span>
<span class="sd">        3D targets. Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, and</span>
<span class="sd">        &#39;target_type&#39;.  &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the</span>
<span class="sd">        position of the target relative to the model origin for its associated value.</span>
<span class="sd">        &#39;target_type&#39; has a string representing the type of target (most commonly &#39;dot&#39;)</span>
<span class="sd">        for its associated value. ``tgts[i]`` is associated with ``img_targets[i]`` for</span>
<span class="sd">        i from 0 to `num_matches`</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        Each dict has, at a minimum, keys &#39;center&#39;, and &#39;target_type&#39;. &#39;center&#39; has a</span>
<span class="sd">        value of the image target center location (tuple/np.ndarray of length 2 of</span>
<span class="sd">        floats) and &#39;target_type&#39; has the key of the type of target (string).</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]``</span>
<span class="sd">    max_dist : float</span>
<span class="sd">        The maximum matching distance between a 3D target&#39;s project and an image targets</span>
<span class="sd">        center. Pairs with matching distance greater this distance are filtered out.</span>
<span class="sd">    debug : tuple, optional</span>
<span class="sd">        Debug option. For no debugging, give None. To generate debugging images, give</span>
<span class="sd">        a tuple of length 3. First item is the image to use as the background.</span>
<span class="sd">        Second item is the name of the debug image. Third item can be a dict or None. If</span>
<span class="sd">        dict, matches will be filtered before the debug image is created. Dict needs to</span>
<span class="sd">        follow test_config input requirements of filter_matches. If None, matches will</span>
<span class="sd">        not be filtered in the debug image</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tgts_matched: list</span>
<span class="sd">        3D targets that are matched</span>
<span class="sd">    matching_img_targets: list</span>
<span class="sd">        Image locations of matched targets</span>
<span class="sd">    num_matches: int</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgts_matched[i]`` is matched with ``matching_img_targets[i]`` for i from 0 to</span>
<span class="sd">    `num_matches`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Match the visible targets to the closest image point</span>
    <span class="n">matching_img_targets</span> <span class="o">=</span> <span class="n">match_obj_and_img_pts</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">max_dist</span>
    <span class="p">)</span>

    <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_img_targets</span><span class="p">,</span> <span class="n">num_matches</span> <span class="o">=</span> <span class="n">filter_nones</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">matching_img_targets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_img_targets</span> <span class="o">=</span> <span class="n">post_filter_append</span><span class="p">(</span>
        <span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">matching_img_targets</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tgts_matched_temp</span><span class="p">,</span> <span class="n">img_targets_temp</span> <span class="o">=</span> <span class="n">filter_matches</span><span class="p">(</span>
                <span class="n">rmat</span><span class="p">,</span>
                <span class="n">tvec</span><span class="p">,</span>
                <span class="n">cameraMatrix</span><span class="p">,</span>
                <span class="n">distCoeffs</span><span class="p">,</span>
                <span class="n">tgts_matched</span><span class="p">,</span>
                <span class="n">matching_img_targets</span><span class="p">,</span>
                <span class="n">num_matches</span><span class="p">,</span>
                <span class="n">debug</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">debug</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">num_matches_temp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts_matched_temp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tgts_matched_temp</span><span class="p">,</span> <span class="n">img_targets_temp</span> <span class="o">=</span> <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_img_targets</span>
            <span class="n">num_matches_temp</span> <span class="o">=</span> <span class="n">num_matches</span>

        <span class="n">tgts_matched_temp_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgts_matched_temp</span><span class="p">)</span>
        <span class="n">tgts_matched_temp_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_matched_temp</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_matched_temp_temp</span><span class="p">:</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">tgts_unmatched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
            <span class="n">tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_matched_temp_temp</span><span class="p">:</span>
                <span class="n">tgts_unmatched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

        <span class="n">img_targets_temp_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_targets_temp</span><span class="p">)</span>
        <span class="n">img_targets_temp_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">img_targets_temp</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">img_tgt</span> <span class="ow">in</span> <span class="n">img_targets_temp_temp</span><span class="p">:</span>
            <span class="n">img_tgt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_tgt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">img_targets_unmatched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">img_tgt</span> <span class="ow">in</span> <span class="n">img_targets</span><span class="p">:</span>
            <span class="n">img_tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_tgt</span><span class="p">)</span>
            <span class="n">img_tgt_temp</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_tgt_temp</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">img_tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">img_targets_temp_temp</span><span class="p">:</span>
                <span class="n">img_targets_unmatched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_tgt</span><span class="p">)</span>

        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts_matched_temp</span> <span class="o">+</span> <span class="n">tgts_unmatched</span>
        <span class="p">)</span>

        <span class="n">proj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">])</span>
        <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets_temp</span> <span class="o">+</span> <span class="n">img_targets_unmatched</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">visualization</span><span class="o">.</span><span class="n">show_projection_matching</span><span class="p">(</span>
            <span class="n">debug</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">proj_pts</span><span class="p">,</span>
            <span class="n">img_centers</span><span class="p">,</span>
            <span class="n">num_matches</span><span class="o">=</span><span class="n">num_matches_temp</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">debug</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">bonus_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_img_targets</span><span class="p">,</span> <span class="n">num_matches</span></div>


<div class="viewcode-block" id="post_filter_append"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.post_filter_append">[docs]</a><span class="k">def</span> <span class="nf">post_filter_append</span><span class="p">(</span><span class="n">tgts</span><span class="p">,</span> <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">img_targets_filtered</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds tgts that were filtered back into the list</span>

<span class="sd">    The match-and-filter scheme we use is to have two ordered lists, where</span>
<span class="sd">    ``tgts_filtered[i]`` is matched to ``img_targets_filtered[i]`` for i from 0 to</span>
<span class="sd">    `num_matches`. For i greater than num_matches, the tgt and img_target are not</span>
<span class="sd">    matched. We leave all unmatched targets in the list, because some filtering</span>
<span class="sd">    operations need them. Ex the the filters for min_dist and bi_filter.</span>

<span class="sd">    This function takes in the whole (randomly ordered) `tgts` and `img_targets`, as</span>
<span class="sd">    well as the (ordered) `tgts_filtered` and `img_targets_filtered`. Any `tgts` not in</span>
<span class="sd">    `tgts_filtered` are appended at the end, and similar for the `img_targets`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        List of all targets, order is not important. Each target is a dict that has, at</span>
<span class="sd">        a minimum, the keys &#39;tvec&#39;, and &#39;target_type&#39;. If isMatched is False, &#39;norm&#39; is</span>
<span class="sd">        additionally needed as a key. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1)</span>
<span class="sd">        representing the position of the target relative to the model origin for its</span>
<span class="sd">        associated value. &#39;target_type&#39; has a string representing the type of target</span>
<span class="sd">        (most commonly &#39;dot&#39;) for its associated value.</span>
<span class="sd">    tgts_filtered : list of dict</span>
<span class="sd">        List of filtered targets, order is important. ``tgts_filtered[i]`` is associated</span>
<span class="sd">        with ``img_targets_filtered[i]`` for i from 0 to `num_matches`. Each target is a</span>
<span class="sd">        dict that has, at a minimum, the keys &#39;tvec&#39;, and &#39;target_type&#39;. If isMatched is</span>
<span class="sd">        False, &#39;norm&#39; is additionally needed as a key. &#39;tvec&#39; has a</span>
<span class="sd">        :class:`numpy.ndarray` (3, 1) representing the position of the target relative</span>
<span class="sd">        to the model origin for its associated value. &#39;target_type&#39; has a string</span>
<span class="sd">        representing the type of target (most commonly &#39;dot&#39;) for its associated value.</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        List of all matched image targets, order is not important. Each dict has, at a</span>
<span class="sd">        minimum, keys &#39;center&#39;, and &#39;target_type&#39;. &#39;center&#39; has a value of the image</span>
<span class="sd">        target center location (tuple/np.ndarray of length 2 of floats) and</span>
<span class="sd">        &#39;target_type&#39; has the key of the type of target (string).</span>
<span class="sd">    img_targets_filtered : list of dict</span>
<span class="sd">        List of filtered image targets, order is important. ``img_targets_filtered[i]``</span>
<span class="sd">        is associated with ``tgts_filtered[i]`` for i from 0 to `num_matches`. Each dict</span>
<span class="sd">        has, at a minimum, keys &#39;center&#39;, and &#39;target_type&#39;. &#39;center&#39; has a value of the</span>
<span class="sd">        image target center location (tuple/np.ndarray of length 2 of floats) and</span>
<span class="sd">        &#39;target_type&#39; has the key of the type of target (string).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tgts_filtered_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgts_filtered</span><span class="p">)</span>
    <span class="n">img_targets_filtered_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_targets_filtered</span><span class="p">)</span>

    <span class="n">tgts_filtered_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgts_filtered</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts_filtered_list</span><span class="p">)):</span>
        <span class="n">tgts_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgts_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">tgts_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgts_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Add tgts that were not matched</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="n">tgt_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
        <span class="n">tgt_list</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_list</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">tgt_list</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_list</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tgt_list</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_filtered_list</span><span class="p">:</span>
            <span class="n">tgts_filtered_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

    <span class="n">img_targets_filtered_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_targets_filtered</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets_filtered_list</span><span class="p">)):</span>
        <span class="n">img_targets_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">img_targets_filtered_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="c1"># Add img_target that were not matched</span>
    <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">img_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img_target_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>
            <span class="n">img_target_list</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_target_list</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">img_target_list</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">img_targets_filtered_list</span><span class="p">:</span>
                <span class="n">img_targets_filtered_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_filtered_temp</span><span class="p">,</span> <span class="n">img_targets_filtered_temp</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># External Calibration Wrappers</span>


<div class="viewcode-block" id="external_calibrate"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.external_calibrate">[docs]</a><span class="k">def</span> <span class="nf">external_calibrate</span><span class="p">(</span>
    <span class="n">img</span><span class="p">,</span>
    <span class="n">rmat</span><span class="p">,</span>
    <span class="n">tvec</span><span class="p">,</span>  <span class="c1"># Frame specific</span>
    <span class="n">cameraMatrix</span><span class="p">,</span>
    <span class="n">distCoeffs</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">tgts</span><span class="p">,</span>
    <span class="n">img_targets</span><span class="p">,</span>
    <span class="n">vis_checker</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">,</span>  <span class="c1"># Config specific</span>
    <span class="n">isMatched</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Test specific</span>
    <span class="n">reprojectionError</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span>  <span class="c1"># Test specific (should be stable between tests)</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set up and run solvePnPRansac to get the external calibration and inlier targets</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (height, width)</span>
<span class="sd">        Image to use for calibration</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict that has, at a minimum, the keys &#39;tvec&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. If isMatched is False, &#39;norm&#39; is additionally needed as a key.</span>
<span class="sd">        &#39;tvec&#39; has a np.ndarray (3, 1) representing the position of the target relative</span>
<span class="sd">        to the model origin for its associated value. &#39;target_type&#39; has a string</span>
<span class="sd">        representing the type of target (most commonly &#39;dot&#39;) for its associated value.</span>
<span class="sd">        ``tgts[i]`` is associated with ``img_targets[i]`` for i from 0 to `num_matches`.</span>
<span class="sd">        &#39;norm&#39; has a :class:`numpy.ndarray` (3, 1) representing the normal vector of the</span>
<span class="sd">        target relative to the model coordinate system for its associated value</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        Matched image targets. Each dict has, at a minimum, keys &#39;center&#39;, and</span>
<span class="sd">        &#39;target_type&#39;. &#39;center&#39; has a value of the image target center location</span>
<span class="sd">        (tuple/np.ndarray of length 2 of floats) and &#39;target_type&#39; has the key of the</span>
<span class="sd">        type of target (string). ``img_targets[i]`` is associated with ``tgts[i]``</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        dict with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;, and each target type</span>
<span class="sd">        in targets and img_targets. &#39;min_dist&#39; is the minimum distance between two image</span>
<span class="sd">        targets. &#39;max_dist&#39; is the maximum allowable distance between an image target</span>
<span class="sd">        and the projection of a 3D target. The key for each target type is</span>
<span class="sd">        `target_type` + &#39;_pad&#39;. This is the padding around the img target center</span>
<span class="sd">        location to use to sub-pixel localize</span>
<span class="sd">    isMatched : bool</span>
<span class="sd">        If True, denotes that ``tgts[i]`` is associated with ``img_targets[i]`` and all</span>
<span class="sd">        targets are visible to the camera. If False, denotes `tgts` and `img_targets`</span>
<span class="sd">        are not in any particular order. If False, targets are checked for visibility</span>
<span class="sd">        and :func:`match_targets` is used to match the tgts to the image targets</span>
<span class="sd">    max_localize_delta : float, optional</span>
<span class="sd">        Parameter passed to :func:`subpixel_localize`</span>
<span class="sd">    reprojectionError : float, optional</span>
<span class="sd">        Maximum reprojection error between a target and image target to be considered an</span>
<span class="sd">        inlier. ReprojectionError is often smaller than ``test_config[&#39;max_dist&#39;]``</span>
<span class="sd">        since it is the optimized distance between the target and image target.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmat_opt</span>
<span class="sd">        optimized rotation matrix from the camera to the model</span>
<span class="sd">    tvec_opt</span>
<span class="sd">        optimized translation vector from the camera to the model</span>
<span class="sd">    tgt_inliers</span>
<span class="sd">        list of inlier targets of the optimization</span>
<span class="sd">    img_target_inliers</span>
<span class="sd">        list of the inlier image targets of the optimization</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``tgt_inliers[i]`` is associated with ``img_target_inliers[i]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the inputs are not matched, get the visible targets and match them.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isMatched</span><span class="p">:</span>
        <span class="c1"># Determine which targets are visible</span>
        <span class="n">visibles_tgts</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
        <span class="p">)</span>

        <span class="c1"># Match the projected locations to the image locations</span>
        <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">img_targets_matched</span><span class="p">,</span> <span class="n">num_matches_init</span> <span class="o">=</span> <span class="n">match_targets</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span>
            <span class="n">tvec</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">visibles_tgts</span><span class="p">,</span>
            <span class="n">img_targets</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="c1"># If the input is matched, short circuit the tgt_matched and</span>
    <span class="c1">#   img_targets_matched with the inputs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tgts_matched</span> <span class="o">=</span> <span class="n">tgts</span>
        <span class="n">img_targets_matched</span> <span class="o">=</span> <span class="n">img_targets</span>
        <span class="n">num_matches_init</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span>

    <span class="c1"># Filter the matched targets</span>
    <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">filter_matches</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span>
        <span class="n">tvec</span><span class="p">,</span>
        <span class="n">cameraMatrix</span><span class="p">,</span>
        <span class="n">distCoeffs</span><span class="p">,</span>
        <span class="n">tgts_matched</span><span class="p">,</span>
        <span class="n">img_targets_matched</span><span class="p">,</span>
        <span class="n">num_matches_init</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Sub-pixel localize the image targets</span>
    <span class="n">tgts_subpixel</span><span class="p">,</span> <span class="n">img_targets_subpixel</span> <span class="o">=</span> <span class="n">subpixel_localize</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">tgts_filtered</span><span class="p">,</span>
        <span class="n">img_targets_filtered</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">max_localize_delta</span><span class="o">=</span><span class="n">max_localize_delta</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># If there are less than 4 matches, raise an error</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts_subpixel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Less than 4 matches were found in external_calibrate. &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;This can be due to blob detection finding too few targets, too few &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;visible targets, a bad matching scheme due to a bad starting pose &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;(rmat and tvec), and/or too many targets rejected during the sub-pixel &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;localization.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Package the target tvecs</span>
    <span class="n">tgt_tvecs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_subpixel</span><span class="p">:</span>
        <span class="n">tgt_tvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">])</span>
    <span class="n">tgt_tvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tgt_tvecs</span><span class="p">)</span>

    <span class="c1"># Package the image points</span>
    <span class="n">img_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">img_targets_subpixel</span><span class="p">:</span>
        <span class="n">img_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">])</span>
    <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_centers</span><span class="p">)</span>

    <span class="c1"># Convert rmat to rvec</span>
    <span class="n">rvec</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span>

    <span class="c1"># Solve for the new tvec and rvec</span>
    <span class="n">retval</span><span class="p">,</span> <span class="n">rvec_opt</span><span class="p">,</span> <span class="n">tvec_opt</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">solvePnPRansac</span><span class="p">(</span>
        <span class="n">tgt_tvecs</span><span class="p">,</span>
        <span class="n">img_centers</span><span class="p">,</span>
        <span class="n">cameraMatrix</span><span class="p">,</span>
        <span class="n">distCoeffs</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tvec</span><span class="p">),</span>
        <span class="n">reprojectionError</span><span class="o">=</span><span class="n">reprojectionError</span><span class="p">,</span>
        <span class="n">useExtrinsicGuess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inliers</span><span class="p">):</span>
        <span class="n">inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">inliers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Package all the inlier matching points</span>
    <span class="n">tgt_inliers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img_target_inliers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inliers</span><span class="p">:</span>
        <span class="n">tgt_inliers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgts_subpixel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">img_target_inliers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_targets_subpixel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Convert rvec_opt to rmat_opt</span>
    <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rvec_opt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">tvec_opt</span><span class="p">,</span> <span class="n">tgt_inliers</span><span class="p">,</span> <span class="n">img_target_inliers</span></div>


<div class="viewcode-block" id="check_external_calibrate_two_stage_inputs"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.check_external_calibrate_two_stage_inputs">[docs]</a><span class="k">def</span> <span class="nf">check_external_calibrate_two_stage_inputs</span><span class="p">(</span>
    <span class="n">img</span><span class="p">,</span> <span class="n">rmat_init_guess</span><span class="p">,</span> <span class="n">tvec_init_guess</span><span class="p">,</span> <span class="n">incal</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">test_config</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">,</span> <span class="n">debug</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check that the inputs to external calibrate are valid</span>

<span class="sd">    Helper function to :func:`external_calibrate_two_stage`. Checks that the input are</span>
<span class="sd">    of the proper type, size, format, and have the relevant attributes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (h, w)</span>
<span class="sd">        Numpy 2D array of the image</span>
<span class="sd">    rmat_init_guess : np.ndarray (3, 3), float</span>
<span class="sd">        Initial guess of rotation matrix from camera to object</span>
<span class="sd">    tvec_init_guess : np.ndarray (3, 1), float</span>
<span class="sd">        Initial guess of translation vector from camera to object</span>
<span class="sd">    incal : tuple</span>
<span class="sd">        Camera internal calibration.</span>

<span class="sd">        - ``cameraMatrix`` (:class:`numpy.ndarray`, shape (3, 3)): The (OpenCV</span>
<span class="sd">          formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` (:class:`numpy.ndarray`, shape (1, 5): The (OpenCV formatted)</span>
<span class="sd">          distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, &#39;target_type&#39;,</span>
<span class="sd">        &#39;norm&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the position of</span>
<span class="sd">        the target relative to the model origin for its associated value. &#39;norm&#39; has a</span>
<span class="sd">        :class:`numpy.ndarray` (3, 1) representing the normal vector of the target</span>
<span class="sd">        relative to the model origin for its associated value. &#39;target_type&#39; has a</span>
<span class="sd">        string representing the type of target (most commonly &#39;dot&#39;) for its associated</span>
<span class="sd">        value. ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;, and</span>
<span class="sd">        2 keys for the primary target type in targets and img_targets. &#39;min_dist&#39; is the</span>
<span class="sd">        minimum distance between two image targets. &#39;max_dist&#39; is the maximum allowable</span>
<span class="sd">        distance between an image target and the projection of a 3D target. The primary</span>
<span class="sd">        target type is &#39;dot&#39; if there are 4+ dots in tgts. Otherwise the primary target</span>
<span class="sd">        type is &#39;kulite&#39;. The keys for the primary target type are target_type + &#39;_pad&#39;</span>
<span class="sd">        and `target_type` + &#39;_blob_parameters&#39;. The first is the padding around the img</span>
<span class="sd">        target center location to use to sub-pixel localize. The second is the blob</span>
<span class="sd">        detection parameters for that type of target</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    debug : string, optional</span>
<span class="sd">        Name for all debug images (potentially camera name, test an camera name, etc).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if the all inputs are valid, False if any input is invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Any time &quot;isinstance(OBJ, list)&quot; is called, np.array(OBJ) should be inside</span>
    <span class="c1">#   of a try-except in case it has degenerate objects</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check img input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;img dtype should be uint8 not&quot;</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If img is not 2 dimensional, it should be 3 dimensional, but single channel</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;img should be single channel, not&quot;</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;channel&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># img is not 2 dimensional or 3 dimension. Must be an error</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;img should be 2 dimensional, or 3 dimensional and single channel. Not &quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;img type should be np.ndarray. Not &quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check rmat_init_guess input</span>

    <span class="c1"># Check rmat_init_guess is a numpy array of shape (3, 3)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rmat_init_guess</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rmat_init_guess</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="n">rmat_init_guess</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;rmat_init_guess.dtype should be float32 or float64 not&quot;</span><span class="p">,</span>
                <span class="n">rmat_init_guess</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">rmat_init_guess</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rmat_init_guess.shape should be (3, 3). Not &quot;</span><span class="p">,</span> <span class="n">rmat_init_guess</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">isRotationMatrix</span><span class="p">(</span><span class="n">rmat_init_guess</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rmat_init_guess is not a valid rotation matrix&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rmat_init_guess should be np.ndarray. Not&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">rmat_init_guess</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check tvec_init_guess input</span>

    <span class="c1"># Check tvec_init_guess is a numpy array of shape (3, 1)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tvec_init_guess</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tvec_init_guess</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="n">tvec_init_guess</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;tvec_init_guess.dtype should be float32 or float64 not&quot;</span><span class="p">,</span>
                <span class="n">tvec_init_guess</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">tvec_init_guess</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tvec_init_guess.shape should be (3, 1). Not &quot;</span><span class="p">,</span> <span class="n">tvec_init_guess</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tvec_init_guess should be np.ndarray. Not&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">tvec_init_guess</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check incal input</span>

    <span class="c1"># if incal[0] is a list, convert it to a numpy array to check the data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0].dtype should be float32 or float64 not&quot;</span><span class="p">,</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0].shape should be (3, 3). Not &quot;</span><span class="p">,</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># incal should be of the form [[fx, 0, cx], [0, fy, cy], [0, 0, 1]]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0][2] must be [0, 0, 1]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0][0][1] must be 0&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0][1][0] must be 0&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[0] should be np.ndarray or list. Not&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># if incal[1] is a list, convert it to a numpy array to check the data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[1].dtype should be float32 or float64 not&quot;</span><span class="p">,</span> <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[1].shape should be (1, 5). Not &quot;</span><span class="p">,</span> <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;incal[1] should be np.ndarray or list. Not&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check tgts input</span>

    <span class="c1"># Check that each target is as expected</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;tvec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgt</span> <span class="ow">or</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgt</span> <span class="ow">or</span> <span class="s2">&quot;target_type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgt</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Each item in tgts must have a tvec, norm, and target_type. One or more of the items in tgts did not meet this criteria&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;tgt tvec and norm must have shape (3, 1). One or more of the items in tgts did not meet this criteria&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;tgt tvec and norm must be np.ndarray. One or more of the items in tgts did not meet this criteria&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tgts must have at least 4 items. Only&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">),</span> <span class="s2">&quot;were found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check test_config input</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;dot_blob_parameters&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="s2">&quot;kulite_blob_parameters&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Neither &#39;dot_blob_parameters&#39; nor &#39;kulite_blob_parameters&#39; in test_config.keys()&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="s2">&quot;dot_blob_parameters&quot;</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;dot_blob_parameters&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;test_config[&#39;dot_blob_parameters&#39;] should be a list, not&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;dot_blob_parameters&quot;</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="s2">&quot;kulite_blob_parameters&quot;</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;kulite_blob_parameters&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;test_config[&#39;kulite_blob_parameters&#39;] should be a list, not&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;kulite_blob_parameters&quot;</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># TODO: Need to check that test_config[&#39;blob_parameters&#39;] contains all valid</span>
    <span class="c1">#   items. But that is a lot of work, and it fails early enough in</span>
    <span class="c1">#   external_calibration_two_stage that it doesn&#39;t matter much</span>

    <span class="k">if</span> <span class="s2">&quot;max_dist&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;max_dist&#39; not in test_config.keys()&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test_config[&#39;max_dist&#39;] must be numeric&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="s2">&quot;min_dist&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_config</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;min_dist&#39; not in test_config.keys()&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;min_dist&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test_config[&#39;min_dist&#39;] must be numeric&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check vis_checker input</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">vis_checker</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;VisibilityChecker&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;vis_checker should be visibility.VisibilityChecker object. Not&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">vis_checker</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">vis_checker</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;BVH&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;vis_checker.scene should be upsp.raycast.CreateBVH object. Not&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">vis_checker</span><span class="o">.</span><span class="n">scene</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Check debug input</span>

    <span class="c1"># If debug is not None object, a string, or integer then it is improper</span>
    <span class="k">if</span> <span class="n">debug</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;debug should be None, string, or int. Not&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">debug</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="external_calibrate_two_stage_from_wtd"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.external_calibrate_two_stage_from_wtd">[docs]</a><span class="k">def</span> <span class="nf">external_calibrate_two_stage_from_wtd</span><span class="p">(</span>
    <span class="n">img</span><span class="p">,</span>  <span class="c1"># Frame specific</span>
    <span class="n">tunnel_vals</span><span class="p">,</span>  <span class="c1"># Datapoint specific</span>
    <span class="n">camera_tunnel_cal</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">tgts</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">,</span>
    <span class="n">vis_checker</span><span class="p">,</span>  <span class="c1"># Test/configuration specific</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper function to :func:`external_calibrate_two_stage`.</span>

<span class="sd">    The `tunnel_vals` plus `test_config` are used to estimate an initial guess of `rmat`</span>
<span class="sd">    and `tvec`. That initial guess should project each target&#39;s within ~5 pixels of the</span>
<span class="sd">    associated image target</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (h, w)</span>
<span class="sd">        Numpy 2D array of the image</span>
<span class="sd">    tunnel_vals : dict</span>
<span class="sd">        Wind tunnel data as a dict with (at a minimum) the keys &#39;ALPHA&#39;, &#39;BETA&#39;, &#39;PHI&#39;,</span>
<span class="sd">        and &#39;STRUTZ&#39;. ALPHA, BETA, and PHI are tunnel angles in degrees. STRUTZ is the</span>
<span class="sd">        offset of the tunnel center of rotation for the z axis in inches</span>
<span class="sd">    camera_tunnel_cal : tuple</span>
<span class="sd">        Camera-tunnel calibration</span>

<span class="sd">        - ``rmat_camera_tunnel`` (:class:`numpy.ndarray`, shape (3, 3)): Rotation matrix</span>
<span class="sd">          from camera to tunnel at wind off condition</span>
<span class="sd">        - ``tvec_camera_tunnel`` (:class:`numpy.ndarray`, shape (3, 1)): Translation</span>
<span class="sd">          vector from camera to tunnel at wind off condition</span>
<span class="sd">        - ``cameraMatrix`` (:class:`numpy.ndarray`, shape (3, 3)): The (OpenCV</span>
<span class="sd">          formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` (:class:`numpy.ndarray`, shape (1, 5)): The (OpenCV formatted</span>
<span class="sd">          distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        3D targets. Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;,</span>
<span class="sd">        &#39;target_type&#39;, &#39;norm&#39;. &#39;tvec&#39; has a np.ndarray (3, 1) representing the position</span>
<span class="sd">        of the target relative to the model origin for its associated value. &#39;norm&#39; has</span>
<span class="sd">        a :class:`numpy.ndarray` (3, 1) representing the normal vector of the target</span>
<span class="sd">        relative to the model origin for its associated value. &#39;target_type&#39; has a</span>
<span class="sd">        string representing the type of target (most commonly &#39;dot&#39;) for its associated</span>
<span class="sd">        value. ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;, and</span>
<span class="sd">        2 keys for the primary target type in `targets` and `img_targets`. &#39;min_dist&#39; is</span>
<span class="sd">        the minimum distance between two image targets. &#39;max_dist&#39; is the maximum</span>
<span class="sd">        allowable distance between an image target and the projection of a 3D target.</span>
<span class="sd">        The primary target type is &#39;dot&#39; if there are 4+ dots in tgts. Otherwise the</span>
<span class="sd">        primary target type is &#39;kulite&#39;. The keys for the primary target type are</span>
<span class="sd">        `target_type` + &#39;_pad&#39; and `target_type` + &#39;_blob_parameters&#39;. The first is the</span>
<span class="sd">        padding around the img target center location to use to sub-pixel localize. The</span>
<span class="sd">        second is the blob detection parameters for that type of target</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    debug : string, optional</span>
<span class="sd">        Name for all debug images (potentially camera name, test an camera name, etc)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmat: np.ndarray, shape (3, 3), float</span>
<span class="sd">        camera-to-model external calibration rotation matrix</span>
<span class="sd">    tvec: np.ndarray, shape (3, 1), float</span>
<span class="sd">        camera-to-model external calibration translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that the inputs are valid</span>
    <span class="n">rmat_camera_tunnel</span><span class="p">,</span> <span class="n">tvec_camera_tunnel</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">camera_tunnel_cal</span>
    <span class="n">check_bool</span> <span class="o">=</span> <span class="n">check_external_calibrate_two_stage_inputs</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_camera_tunnel</span><span class="p">,</span>
        <span class="n">tvec_camera_tunnel</span><span class="p">,</span>
        <span class="p">[</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">],</span>
        <span class="n">tgts</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">tunnel_vals_check_bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tunnel_vals</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ALPHA&#39;</span><span class="p">,</span> <span class="s1">&#39;BETA&#39;</span><span class="p">,</span> <span class="s1">&#39;PHI&#39;</span><span class="p">,</span> <span class="s1">&#39;STRUTZ&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tunnel_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">tunnel_vals_check_bool</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;tunnel_vals is missing 1 or more keys. tunnel_vals.keys():&quot;</span><span class="p">,</span> 
                <span class="n">tunnel_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tunnel_vals</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">tunnel_vals_check_bool</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;tunnel_vals values should have type float. Instead&quot;</span><span class="p">,</span> 
                        <span class="s2">&quot;tunnel_vals[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;] is &quot;</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tunnel_vals</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tunnel_vals_check_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;tunnel_vals should have type dict. Instead tunnel_vals has type &quot;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tunnel_vals</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">check_bool</span> <span class="ow">and</span> <span class="n">tunnel_vals_check_bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One or more bad inputs were given to external_calibrate_two_stage_from_wtd&quot;</span>
        <span class="p">)</span>

    <span class="p">(</span>
        <span class="n">rmat_init_guess</span><span class="p">,</span>
        <span class="n">tvec_init_guess</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">camera_tunnel_calibrate</span><span class="o">.</span><span class="n">tf_camera_tgts_thru_tunnel</span><span class="p">(</span>
        <span class="n">camera_tunnel_cal</span><span class="p">,</span> <span class="n">tunnel_vals</span><span class="p">,</span> <span class="n">test_config</span>
    <span class="p">)</span>

    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span> <span class="o">=</span> <span class="n">external_calibrate_two_stage</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_init_guess</span><span class="p">,</span>
        <span class="n">tvec_init_guess</span><span class="p">,</span>
        <span class="n">camera_tunnel_cal</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
        <span class="n">tgts</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span></div>


<div class="viewcode-block" id="external_calibrate_two_stage"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.external_calibrate_two_stage">[docs]</a><span class="k">def</span> <span class="nf">external_calibrate_two_stage</span><span class="p">(</span>
    <span class="n">img</span><span class="p">,</span>  <span class="c1"># Frame specific</span>
    <span class="n">rmat_init_guess</span><span class="p">,</span>
    <span class="n">tvec_init_guess</span><span class="p">,</span>  <span class="c1"># Datapoint specific</span>
    <span class="n">incal</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">tgts</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">,</span>
    <span class="n">vis_checker</span><span class="p">,</span>  <span class="c1"># Test/configuration specific</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs external calibration from an inaccurate initial guess</span>

<span class="sd">    Runs blob detection to find the img targets, then matches and filters the 3D targets</span>
<span class="sd">    to the img targets. Performs a coarse optimization to improve the intial guess. Then</span>
<span class="sd">    calls :func:`external_calibrate_one_step` to get the refined optimization</span>

<span class="sd">    The initial guess of rmat and tvec should project each target&#39;s within ~5 pixels of</span>
<span class="sd">    the associated image target</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (h, w)</span>
<span class="sd">        Numpy 2D array of the image</span>
<span class="sd">    rmat_init_guess : np.ndarray (3, 3), float</span>
<span class="sd">        Initial guess of rotation matrix from camera to object</span>
<span class="sd">    tvec_init_guess : np.ndarray (3, 1), float</span>
<span class="sd">        Initial guess of translation vector from camera to object</span>
<span class="sd">    incal : tuple</span>
<span class="sd">        Camera internal calibration.</span>

<span class="sd">        - ``cameraMatrix`` (:class:`numpy.ndarray`, shape (3, 3)): The (OpenCV</span>
<span class="sd">          formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` (:class:`numpy.ndarray`, shape (1, 5): The (OpenCV formatted)</span>
<span class="sd">          distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, &#39;target_type&#39;,</span>
<span class="sd">        &#39;norm&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the position of</span>
<span class="sd">        the target relative to the model origin for its associated value. &#39;norm&#39; has a</span>
<span class="sd">        :class:`numpy.ndarray` (3, 1) representing the normal vector of the target</span>
<span class="sd">        relative to the model origin for its associated value. &#39;target_type&#39; has a</span>
<span class="sd">        string representing the type of target (most commonly &#39;dot&#39;) for its associated</span>
<span class="sd">        value. ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;, and</span>
<span class="sd">        2 keys for the primary target type in targets and img_targets. &#39;min_dist&#39; is the</span>
<span class="sd">        minimum distance between two image targets. &#39;max_dist&#39; is the maximum allowable</span>
<span class="sd">        distance between an image target and the projection of a 3D target. The primary</span>
<span class="sd">        target type is &#39;dot&#39; if there are 4+ dots in tgts. Otherwise the primary target</span>
<span class="sd">        type is &#39;kulite&#39;. The keys for the primary target type are target_type + &#39;_pad&#39;</span>
<span class="sd">        and target_type + &#39;_blob_parameters&#39;. The first is the padding around the img</span>
<span class="sd">        target center location to use to sub-pixel localize. The second is the blob</span>
<span class="sd">        detection parameters for that type of target</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    debug : string or None. Optional, default=None</span>
<span class="sd">        Name for all debug images (potentially camera name, test an camera name, etc)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3)</span>
<span class="sd">        Valid solution camera-to-model rotation matrix</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1)</span>
<span class="sd">        Valid solution camera-to-model translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that the inputs are valid</span>
    <span class="n">check_bool</span> <span class="o">=</span> <span class="n">check_external_calibrate_two_stage_inputs</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_init_guess</span><span class="p">,</span>
        <span class="n">tvec_init_guess</span><span class="p">,</span>
        <span class="n">incal</span><span class="p">,</span>
        <span class="n">tgts</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Scale the image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img_utils</span><span class="o">.</span><span class="n">scale_image_max_inlier</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="c1"># Check the inputs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One or more bad inputs were given to external_calibrate_two_stage&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Unpack the intrinsics</span>
    <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Check if there are enough dots to use for targets</span>
    <span class="n">dots_found</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">primary_tgts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;dot&quot;</span><span class="p">:</span>
            <span class="n">primary_tgts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

    <span class="c1"># If there were enough dots, use the dots blob parameters</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primary_tgts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">blob_parameters</span> <span class="o">=</span> <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;dot_blob_parameters&quot;</span><span class="p">]</span>

    <span class="c1"># If there were not enough dots, collect the kulites and the kulite blob parameters</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Set the dot_found flag to False</span>
        <span class="n">dots_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">blob_parameters</span> <span class="o">=</span> <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;kulite_blob_parameters&quot;</span><span class="p">]</span>

        <span class="n">primary_tgts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;kulite&quot;</span><span class="p">:</span>
                <span class="n">primary_tgts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

    <span class="c1"># Define the blob detector based on the parameters in the test_config file</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">SimpleBlobDetector_Params</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">blob_param</span> <span class="ow">in</span> <span class="n">blob_parameters</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">blob_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blob_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Run the blob detector</span>
    <span class="n">detector</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">SimpleBlobDetector_create</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">keypoints</span> <span class="o">=</span> <span class="n">detector</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="c1"># Repackage the blob detector keypoints to function like taret image locations</span>
    <span class="n">init_img_targets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">keypoint</span> <span class="ow">in</span> <span class="n">keypoints</span><span class="p">:</span>
        <span class="n">init_img_target</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;kulite&quot;</span><span class="p">}[</span>
                <span class="n">dots_found</span>
            <span class="p">],</span>  <span class="c1"># target_type depends on if enough dots were found</span>
            <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keypoint</span><span class="o">.</span><span class="n">pt</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">init_img_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_img_target</span><span class="p">)</span>

    <span class="c1"># Debug for raw matching information</span>
    <span class="k">if</span> <span class="n">debug_raw_matches</span><span class="p">:</span>
        <span class="n">tgts_visible</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
            <span class="n">rmat_init_guess</span><span class="p">,</span> <span class="n">tvec_init_guess</span><span class="p">,</span> <span class="n">primary_tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
        <span class="p">)</span>

        <span class="n">tgts_match_raw</span><span class="p">,</span> <span class="n">img_targets_match_raw</span><span class="p">,</span> <span class="n">num_matches_raw</span> <span class="o">=</span> <span class="n">match_targets</span><span class="p">(</span>
            <span class="n">rmat_init_guess</span><span class="p">,</span>
            <span class="n">tvec_init_guess</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_visible</span><span class="p">,</span>
            <span class="n">init_img_targets</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">tgts_filtered_raw</span><span class="p">,</span> <span class="n">img_targets_filtered_raw</span> <span class="o">=</span> <span class="n">filter_matches</span><span class="p">(</span>
            <span class="n">rmat_init_guess</span><span class="p">,</span>
            <span class="n">tvec_init_guess</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_match_raw</span><span class="p">,</span>
            <span class="n">img_targets_match_raw</span><span class="p">,</span>
            <span class="n">num_matches_raw</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">tgts_subpixel_raw</span><span class="p">,</span> <span class="n">img_targets_subpixel_raw</span> <span class="o">=</span> <span class="n">subpixel_localize</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span>
            <span class="n">tgts_filtered_raw</span><span class="p">,</span>
            <span class="n">img_targets_filtered_raw</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">,</span>
            <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">num_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_targets_subpixel_raw</span><span class="p">)</span>

        <span class="n">tgts_subpixel_raw_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_subpixel_raw</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_subpixel_raw_temp</span><span class="p">:</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">rms</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">reprojection_error</span><span class="p">(</span>
            <span class="n">rmat_init_guess</span><span class="p">,</span>
            <span class="n">tvec_init_guess</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_subpixel_raw</span><span class="p">,</span>
            <span class="n">img_targets_subpixel_raw</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Raw Num Points: </span><span class="si">%d</span><span class="s2"> RMS: </span><span class="si">%f</span><span class="s2"> Max Error: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tgts_subpixel_raw</span><span class="p">),</span>
            <span class="n">rms</span><span class="p">,</span>
            <span class="n">max_dist</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get a list of the targets that are visible, but weren&#39;t matched</span>
        <span class="n">visible_but_not_matched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_visible</span><span class="p">:</span>
            <span class="n">tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_subpixel_raw_temp</span><span class="p">:</span>
                <span class="n">visible_but_not_matched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

        <span class="c1"># Get projected location the visible target centers in the image</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat_init_guess</span><span class="p">,</span>
            <span class="n">tvec_init_guess</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_subpixel_raw</span> <span class="o">+</span> <span class="n">visible_but_not_matched</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">proj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">])</span>

        <span class="n">found_but_not_matched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt_match_raw</span><span class="p">,</span> <span class="n">img_target_match_raw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">tgts_match_raw</span><span class="p">,</span> <span class="n">img_targets_match_raw</span>
        <span class="p">):</span>
            <span class="n">tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt_match_raw</span><span class="p">)</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_subpixel_raw_temp</span><span class="p">:</span>
                <span class="n">found_but_not_matched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target_match_raw</span><span class="p">)</span>

        <span class="n">all_img_targets</span> <span class="o">=</span> <span class="n">img_targets_subpixel_raw</span> <span class="o">+</span> <span class="n">found_but_not_matched</span>
        <span class="n">img_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">inlier_pt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">inlier_pt</span> <span class="ow">in</span> <span class="n">all_img_targets</span><span class="p">]</span>
        <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_centers</span><span class="p">)</span>

        <span class="c1"># Get the debug name. If debug was given, use it otherwise don&#39;t</span>
        <span class="n">debug_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_raw&quot;</span> <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;raw&quot;</span>

        <span class="c1"># Output a debug image of the projected locations and image target center locations</span>
        <span class="n">visualization</span><span class="o">.</span><span class="n">show_projection_matching</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span>
            <span class="n">proj_pts</span><span class="p">,</span>
            <span class="n">img_centers</span><span class="p">,</span>
            <span class="n">num_matches</span><span class="o">=</span><span class="n">num_matches</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">debug_name</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Check that enough blobs were found</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Less than 4 blobs were found in external_calibrate_two_stage.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Do the coarse external calibration</span>
    <span class="n">coarse_outputs</span> <span class="o">=</span> <span class="n">external_calibrate</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_init_guess</span><span class="p">,</span>
        <span class="n">tvec_init_guess</span><span class="p">,</span>
        <span class="n">cameraMatrix</span><span class="p">,</span>
        <span class="n">distCoeffs</span><span class="p">,</span>
        <span class="n">primary_tgts</span><span class="p">,</span>
        <span class="n">init_img_targets</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">isMatched</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reprojectionError</span><span class="o">=</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Unpack the output variables</span>
    <span class="p">(</span>
        <span class="n">rmat_coarse</span><span class="p">,</span>
        <span class="n">tvec_coarse</span><span class="p">,</span>
        <span class="n">tgts_inliers_coarse</span><span class="p">,</span>
        <span class="n">img_target_inliers_coarse</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">coarse_outputs</span>

    <span class="k">if</span> <span class="n">debug_coarse_optimization</span><span class="p">:</span>
        <span class="n">rms</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">reprojection_error</span><span class="p">(</span>
            <span class="n">rmat_coarse</span><span class="p">,</span>
            <span class="n">tvec_coarse</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_inliers_coarse</span><span class="p">,</span>
            <span class="n">img_target_inliers_coarse</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Coarse Num Points: </span><span class="si">%d</span><span class="s2"> RMS: </span><span class="si">%f</span><span class="s2"> Max Error: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tgts_inliers_coarse</span><span class="p">),</span>
            <span class="n">rms</span><span class="p">,</span>
            <span class="n">max_dist</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get projected location the visible targets in the image</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat_coarse</span><span class="p">,</span> <span class="n">tvec_coarse</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts_inliers_coarse</span>
        <span class="p">)</span>

        <span class="n">proj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">])</span>
        <span class="n">img_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inlier_pt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">inlier_pt</span> <span class="ow">in</span> <span class="n">img_target_inliers_coarse</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get the debug name. If debug was given, use it otherwise don&#39;t</span>
        <span class="n">debug_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_coarse&quot;</span> <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;coarse&quot;</span>

        <span class="n">visualization</span><span class="o">.</span><span class="n">show_projection_matching</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">proj_pts</span><span class="p">,</span> <span class="n">img_pts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">debug_name</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="c1"># Call the one step function for the refined optimization</span>
    <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span> <span class="o">=</span> <span class="n">external_calibrate_one_step</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_coarse</span><span class="p">,</span>
        <span class="n">tvec_coarse</span><span class="p">,</span>
        <span class="n">incal</span><span class="p">,</span>
        <span class="n">primary_tgts</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span></div>


<div class="viewcode-block" id="external_calibrate_one_step"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.external_calibrate_one_step">[docs]</a><span class="k">def</span> <span class="nf">external_calibrate_one_step</span><span class="p">(</span>
    <span class="n">img</span><span class="p">,</span>  <span class="c1"># Frame specific</span>
    <span class="n">rmat_coarse</span><span class="p">,</span>
    <span class="n">tvec_coarse</span><span class="p">,</span>  <span class="c1"># Datapoint specific</span>
    <span class="n">incal</span><span class="p">,</span>  <span class="c1"># Camera specific</span>
    <span class="n">tgts</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">,</span>
    <span class="n">vis_checker</span><span class="p">,</span>  <span class="c1"># Test/configuration specific</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs external calibration from a seim-accurate coarse guess</span>

<span class="sd">    The coarse guess of `rmat` and `tvec` should project each target&#39;s within 1 pixel of</span>
<span class="sd">    the associated image target</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : np.ndarray, shape (h, w)</span>
<span class="sd">        Numpy 2D array of the image</span>
<span class="sd">    rmat_coarse : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Coarsely refined rotation matrix from camera to object</span>
<span class="sd">    tvec_coarse : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Coarsely refined translation vector from camera to object</span>
<span class="sd">    incal : tuple</span>
<span class="sd">        Camera internal calibration.</span>

<span class="sd">        - ``cameraMatrix`` (:class:`numpy.ndarray`, shape (3, 3)): The (OpenCV</span>
<span class="sd">          formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` (:class:`numpy.ndarray`, shape (1, 5): The (OpenCV formatted)</span>
<span class="sd">          distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict and has, at a minimum, the keys &#39;tvec&#39;, &#39;target_type&#39;,</span>
<span class="sd">        &#39;norm&#39;. &#39;tvec&#39; has a :class:`numpy.ndarray` (3, 1) representing the position of</span>
<span class="sd">        the target relative to the model origin for its associated value. &#39;norm&#39; has a</span>
<span class="sd">        :class:`numpy.ndarray` (3, 1) representing the normal vector of the target</span>
<span class="sd">        relative to the model origin for its associated value. &#39;target_type&#39; has a</span>
<span class="sd">        string representing the type of target (most commonly &#39;dot&#39;) for its associated</span>
<span class="sd">        value. ``tgts[i]`` is associated with ``img_targets[i]``</span>
<span class="sd">    test_config : dict</span>
<span class="sd">        Processing parameters with, at a minimum, a key for &#39;min_dist&#39;, &#39;max_dist&#39;, and</span>
<span class="sd">        2 keys for the primary target type in targets and img_targets. &#39;min_dist&#39; is the</span>
<span class="sd">        minimum distance between two image targets. &#39;max_dist&#39; is the maximum allowable</span>
<span class="sd">        distance between an image target and the projection of a 3D target. The primary</span>
<span class="sd">        target type is &#39;dot&#39; if there are 4+ dots in tgts. Otherwise the primary target</span>
<span class="sd">        type is &#39;kulite&#39;. The keys for the primary target type are target_type + &#39;_pad&#39;</span>
<span class="sd">        and target_type + &#39;_blob_parameters&#39;. The first is the padding around the img</span>
<span class="sd">        target center location to use to sub-pixel localize. The second is the blob</span>
<span class="sd">        detection parameters for that type of target</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    debug : string or None. Optional, default=None</span>
<span class="sd">        Name for all debug images (potentially camera name, test an camera name, etc)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmat: np.ndarray, shape (3, 3), float</span>
<span class="sd">        camera-to-model external calibration rotation matrix</span>
<span class="sd">    tvec: np.ndarray, shape (3, 1), float</span>
<span class="sd">        camera-to-model external calibration translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Scale the image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img_utils</span><span class="o">.</span><span class="n">scale_image_max_inlier</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="c1"># Unpack the intrinsics</span>
    <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">incal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Get the visible targets</span>
    <span class="n">visible_tgts</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
        <span class="n">rmat_coarse</span><span class="p">,</span> <span class="n">tvec_coarse</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
    <span class="p">)</span>

    <span class="c1"># Get the projections of the visible targets</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat_coarse</span><span class="p">,</span> <span class="n">tvec_coarse</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">visible_tgts</span>
    <span class="p">)</span>

    <span class="c1"># Package the target projections into img targets</span>
    <span class="n">img_targets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">:</span>
        <span class="n">img_target</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;target_type&quot;</span><span class="p">:</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">],</span>
            <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">img_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_target</span><span class="p">)</span>

    <span class="c1"># Debuf for refined matches</span>
    <span class="k">if</span> <span class="n">debug_refined_matches</span><span class="p">:</span>
        <span class="c1"># Filter the matched targets</span>
        <span class="n">tgts_filtered</span><span class="p">,</span> <span class="n">img_targets_filtered</span> <span class="o">=</span> <span class="n">filter_matches</span><span class="p">(</span>
            <span class="n">rmat_coarse</span><span class="p">,</span>
            <span class="n">tvec_coarse</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">visible_tgts</span><span class="p">,</span>
            <span class="n">img_targets</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">visible_tgts</span><span class="p">),</span>
            <span class="n">test_config</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Subpixel localize the image targets</span>
        <span class="n">tgts_subpixel</span><span class="p">,</span> <span class="n">img_targets_subpixel</span> <span class="o">=</span> <span class="n">subpixel_localize</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span>
            <span class="n">tgts_filtered</span><span class="p">,</span>
            <span class="n">img_targets_filtered</span><span class="p">,</span>
            <span class="n">test_config</span><span class="p">,</span>
            <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">num_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_targets_subpixel</span><span class="p">)</span>

        <span class="n">tgts_subpixel_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_subpixel</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts_subpixel_temp</span><span class="p">:</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Get a list of the targets that are visible, but weren&#39;t matched</span>
        <span class="n">visible_but_not_matched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">visible_tgts</span><span class="p">:</span>
            <span class="n">tgt_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_temp</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tgt_temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tgts_subpixel_temp</span><span class="p">:</span>
                <span class="n">visible_but_not_matched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>

        <span class="c1"># Get projected location the visible target centers in the image</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat_coarse</span><span class="p">,</span>
            <span class="n">tvec_coarse</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_subpixel</span> <span class="o">+</span> <span class="n">visible_but_not_matched</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">proj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">])</span>

        <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">img_target</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_target</span> <span class="ow">in</span> <span class="n">img_targets_subpixel</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">rms</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">reprojection_error</span><span class="p">(</span>
            <span class="n">rmat_coarse</span><span class="p">,</span>
            <span class="n">tvec_coarse</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_subpixel</span><span class="p">,</span>
            <span class="n">img_targets_subpixel</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get the debug name. If debug was given, use it otherwise don&#39;t</span>
        <span class="n">debug_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_refined&quot;</span> <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;refined&quot;</span>

        <span class="c1"># Output a debug image of the projected locations and image target center locations</span>
        <span class="n">visualization</span><span class="o">.</span><span class="n">show_projection_matching</span><span class="p">(</span>
            <span class="n">img</span><span class="p">,</span>
            <span class="n">proj_pts</span><span class="p">,</span>
            <span class="n">img_centers</span><span class="p">,</span>
            <span class="n">num_matches</span><span class="o">=</span><span class="n">num_matches</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">debug_name</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Run the refined external calibration</span>
    <span class="n">refined_outputs</span> <span class="o">=</span> <span class="n">external_calibrate</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">rmat_coarse</span><span class="p">,</span>
        <span class="n">tvec_coarse</span><span class="p">,</span>
        <span class="n">cameraMatrix</span><span class="p">,</span>
        <span class="n">distCoeffs</span><span class="p">,</span>
        <span class="n">visible_tgts</span><span class="p">,</span>
        <span class="n">img_targets</span><span class="p">,</span>
        <span class="n">vis_checker</span><span class="p">,</span>
        <span class="n">test_config</span><span class="p">,</span>
        <span class="n">isMatched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_localize_delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reprojectionError</span><span class="o">=</span><span class="n">test_config</span><span class="p">[</span><span class="s2">&quot;max_dist&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Unpack the refined results</span>
    <span class="p">(</span>
        <span class="n">rmat_refined</span><span class="p">,</span>
        <span class="n">tvec_refined</span><span class="p">,</span>
        <span class="n">tgts_inliers_refined</span><span class="p">,</span>
        <span class="n">img_target_inliers_refined</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">refined_outputs</span>

    <span class="c1"># Debug for refined optimization</span>
    <span class="k">if</span> <span class="n">debug_refined_optimization</span><span class="p">:</span>
        <span class="n">rms</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">reprojection_error</span><span class="p">(</span>
            <span class="n">rmat_refined</span><span class="p">,</span>
            <span class="n">tvec_refined</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">tgts_inliers_refined</span><span class="p">,</span>
            <span class="n">img_target_inliers_refined</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Refined Num Points: </span><span class="si">%d</span><span class="s2"> RMS: </span><span class="si">%f</span><span class="s2"> Max Error: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tgts_inliers_refined</span><span class="p">),</span>
            <span class="n">rms</span><span class="p">,</span>
            <span class="n">max_dist</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get projected location the visible targets in the image</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts_inliers_refined</span>
        <span class="p">)</span>

        <span class="c1"># Plot the kulites in blue and dots in red</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">c</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;kulite&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">:</span> <span class="s2">&quot;r&quot;</span><span class="p">}[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]],</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Get the debug name. If debug was given, use it otherwise don&#39;t</span>
        <span class="n">debug_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_refined_optimization.png&quot;</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="o">!=</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="s2">&quot;refined_optimization.png&quot;</span>
        <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">debug_name</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Secondary debug to project all visible targets, not just the targets used in the</span>
    <span class="c1">#   optimization</span>
    <span class="k">if</span> <span class="n">debug_visible_projections</span><span class="p">:</span>
        <span class="c1"># Get visible targets</span>
        <span class="n">visible_tgts</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
            <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
        <span class="p">)</span>

        <span class="c1"># Get projected location the visible targets in the image</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_targets</span><span class="p">(</span>
            <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">visible_tgts</span>
        <span class="p">)</span>

        <span class="c1"># Plot the kulites in blue and dots in red</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tgt_projs</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;proj&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">c</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;kulite&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">:</span> <span class="s2">&quot;r&quot;</span><span class="p">}[</span><span class="n">tgt_proj</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]],</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Get the debug name. If debug was given, use it otherwise don&#39;t</span>
        <span class="n">debug_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_visible_projection.png&quot;</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="s2">&quot;visible_projection.png&quot;</span>
        <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">debug_name</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rmat_refined</span><span class="p">,</span> <span class="n">tvec_refined</span></div>


<div class="viewcode-block" id="external_calibrate_RANSAC"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.external_calibrate.html#upsp.cam_cal_utils.external_calibrate.external_calibrate_RANSAC">[docs]</a><span class="k">def</span> <span class="nf">external_calibrate_RANSAC</span><span class="p">(</span>
    <span class="n">incal</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">match_thresh</span><span class="o">=</span><span class="mf">0.80</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use RANSAC to find an external calibration with brute force</span>

<span class="sd">    To find an external calibration, select at random 3 targets and 3 img targets. Solve</span>
<span class="sd">    the associated P3P problem to get the external calibration(s). For each of the</span>
<span class="sd">    external calibrations (P3P can yield up to 4), find the visible targets, project</span>
<span class="sd">    them, and match them to the image targets. If there is sufficient consensus amoung</span>
<span class="sd">    the matches (i.e. the randomly selected targets and image targets yields a solution</span>
<span class="sd">    where many other unselected targets project to a location close to an image target),</span>
<span class="sd">    return that external calibration. If there is not sufficient consensus, repeat this</span>
<span class="sd">    process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    incal : tuple</span>
<span class="sd">        Camera internal calibration.</span>

<span class="sd">        - ``cameraMatrix`` (:class:`numpy.ndarray`, shape (3, 3)): The (OpenCV</span>
<span class="sd">          formatted) camera matrix for the camera</span>
<span class="sd">        - ``distCoeffs`` (:class:`numpy.ndarray`, shape (1, 5): The (OpenCV formatted)</span>
<span class="sd">          distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) &#39;tvec&#39;, &#39;norm&#39;, and &#39;target_type&#39;</span>
<span class="sd">        attributes. The &#39;tvec&#39; attribute gives the target&#39;s location and the &#39;norm&#39;</span>
<span class="sd">        attribute gives the target&#39;s normal vector. &#39;target_type&#39; is a string denoting</span>
<span class="sd">        the type of target (most commonly &#39;dot&#39; or &#39;kulite&#39;)</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        Each img_target is a dict with (at a minimum) a &#39;center&#39; attribute. The &#39;center&#39;</span>
<span class="sd">        attribute gives the pixel position of the target&#39;s center in the image.</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]``</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        VisibilityChecker object with the relevant BVH and oblique viewing angle</span>
<span class="sd">    max_iter : int or float, optional</span>
<span class="sd">        If int, it represents the maximum number of iterations for RANSAC. If float must</span>
<span class="sd">        be greater than 0 but less than 1. Float means it represents the number of</span>
<span class="sd">        estimate number of iterations in order to have that probability of finding a</span>
<span class="sd">        solution should one exist (0.999 means there&#39;s a 99.9% chance of finding a</span>
<span class="sd">        solution should one exist)</span>
<span class="sd">    max_dist : int or float, optional</span>
<span class="sd">        Maximum matching distance between image targets and projected target location</span>
<span class="sd">    match_thresh : int or float, optional</span>
<span class="sd">        If int, this is the number of matches that must be found to deem it a consensus.</span>
<span class="sd">        If float, must be greater than 0 but less than 1. If float, this is the</span>
<span class="sd">        proportion of tgts or img_targets (whichever is lower) that must be matched.</span>
<span class="sd">        I.e. If match_thresh is 0.8 and there are 50 target and 20 img_targets, there</span>
<span class="sd">        must be 16+ matches for it to be deemed a consensus.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3)</span>
<span class="sd">        Rotation matrix. May be ``None`` if the maximum number of iterations is met</span>
<span class="sd">        without finding a valid solution.</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1)</span>
<span class="sd">        Translation vector. May be ``None`` if the maximum number of iterations is met</span>
<span class="sd">        without finding a valid solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Seed the random number generator at the start of the routine</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">incal</span>

    <span class="c1"># &#39;Fake&#39; visibility checker object with no grid which is used to speed up computation</span>
    <span class="n">vis_checker_nogrid</span> <span class="o">=</span> <span class="n">visibility</span><span class="o">.</span><span class="n">VisibilityChecker</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">oblique_angle</span><span class="o">=</span><span class="n">vis_checker</span><span class="o">.</span><span class="n">oblique_angle</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="n">vis_checker</span><span class="o">.</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">debug_nogrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># If match_thresh is between 0 and 1, get the number of matches required</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">match_thresh</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Take the minimum of the proportion of tgts and img_targets</span>
        <span class="n">match_thresh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">*</span> <span class="n">match_thresh</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets</span><span class="p">)</span> <span class="o">*</span> <span class="n">match_thresh</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># match_thresh must be at least 4 for any consensus (3 are used for P3P, so at</span>
        <span class="c1">#   least 1 additional is required for the smallest consensus)</span>
        <span class="n">match_thresh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">match_thresh</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="c1"># If max_iter is a float of 1.0, user wanted probability of 1, so repeat infinite times</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_iter</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># If max_iter is None, find the value of max_iter such that there is a 99% chance of</span>
    <span class="c1">#   find the solution if it exists</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">max_iter</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Estimated number of visible targets based on oblique viewing angle and</span>
        <span class="c1">#   assuming targets are equally distributed</span>
        <span class="n">est_vis_targs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">*</span> <span class="n">vis_checker</span><span class="o">.</span><span class="n">oblique_angle</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="c1"># Expected number of iterations to find 3 visible targets</span>
        <span class="n">exp_3_vis_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_3_vis_den</span> <span class="o">=</span> <span class="n">est_vis_targs</span> <span class="o">*</span> <span class="p">(</span><span class="n">est_vis_targs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">est_vis_targs</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_3_vis</span> <span class="o">=</span> <span class="n">exp_3_vis_num</span> <span class="o">/</span> <span class="n">exp_3_vis_den</span>

        <span class="c1"># Expected number of iterations to choose all 3 correct image target</span>
        <span class="n">exp_img</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_targets</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_targets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Probability of find a solution per iteration</span>
        <span class="n">P</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">exp_3_vis</span> <span class="o">*</span> <span class="n">exp_img</span><span class="p">)</span>

        <span class="c1"># Binomial equations is: b(x, n, p) = [n! / (x! (n - x)!)] * P^x * (1-P)^(n-x)</span>
        <span class="c1"># Using that equation, simply knowing we want the probabily of x=0 to be</span>
        <span class="c1"># (1-max_iter)</span>
        <span class="c1"># (1-max_iter) = (1-P)^n =&gt; n = log(1-max_iter) / log(1-P)</span>
        <span class="c1"># Where n is max_iter</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">max_iter</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Get a list of indicies of the tgts</span>
    <span class="n">tgt_tvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt</span><span class="p">[</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">])</span>
    <span class="n">tgt_tvecs_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgt_tvecs</span><span class="p">))</span>

    <span class="c1"># Get a list of indicies of the image targets</span>
    <span class="n">img_target_projs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">img_tgt</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_tgt</span> <span class="ow">in</span> <span class="n">img_targets</span><span class="p">])</span>
    <span class="n">img_target_projs_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_target_projs</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;tgt_tvecs:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgt_tvecs</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;, img_target_projs:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_target_projs</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;match_thresh:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">match_thresh</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, max_iter:&quot;</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>

    <span class="c1"># RANSAC Operation:</span>
    <span class="c1">#   Select at random 3 tgts and 3 img targats. Solve the corresponding P3P problem,</span>
    <span class="c1">#   and check for consensus with the other target projections and image targets.</span>
    <span class="c1">#   If there is good consensus, leave the loop</span>
    <span class="c1"># We do not cache random guesses because there are likely hundreds of millions of</span>
    <span class="c1">#   possible guesses (depending on length of tgts and img_targets), and it takes on</span>
    <span class="c1">#   the order of a couple hundred thousand to find a solution (again depending on</span>
    <span class="c1">#   length of tgts and img_targets). So randomly generating the same guess twice</span>
    <span class="c1">#   will be relatively rare, and it is faster to generate the same guess twice</span>
    <span class="c1">#   rather than have to cache each guess and check each guess against the cache</span>
    <span class="n">max_num_matches</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_rmat</span><span class="p">,</span> <span class="n">max_tvec</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>
        <span class="c1"># Select 3 random targets</span>
        <span class="n">rand_tgts_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tgt_tvecs_idxs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">rand_tgts</span> <span class="o">=</span> <span class="n">tgt_tvecs</span><span class="p">[</span><span class="n">rand_tgts_idxs</span><span class="p">]</span>

        <span class="c1"># Select 3 random image targets</span>
        <span class="n">rand_img_targets_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">img_target_projs_idxs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">rand_img_targets</span> <span class="o">=</span> <span class="n">img_target_projs</span><span class="p">[</span><span class="n">rand_img_targets_idxs</span><span class="p">]</span>

        <span class="c1"># Solve the associated P3P problem</span>
        <span class="n">retval</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">solveP3P</span><span class="p">(</span>
            <span class="n">rand_tgts</span><span class="p">,</span>
            <span class="n">rand_img_targets</span><span class="p">,</span>
            <span class="n">cameraMatrix</span><span class="p">,</span>
            <span class="n">distCoeffs</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">SOLVEPNP_P3P</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check each potential solution from the P3P solutions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retval</span><span class="p">):</span>
            <span class="c1"># Get the rmat and tvec</span>
            <span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span> <span class="o">=</span> <span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rmat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span>

            <span class="c1"># Get the visible targets</span>
            <span class="n">tgts_vis</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
                <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker_nogrid</span>
            <span class="p">)</span>

            <span class="c1"># If there are too few visible targets, continue</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts_vis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">match_thresh</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Match the visible targets</span>
            <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span> <span class="o">=</span> <span class="n">match_targets</span><span class="p">(</span>
                <span class="n">rmat</span><span class="p">,</span>
                <span class="n">tvec</span><span class="p">,</span>
                <span class="n">cameraMatrix</span><span class="p">,</span>
                <span class="n">distCoeffs</span><span class="p">,</span>
                <span class="n">tgts_vis</span><span class="p">,</span>
                <span class="n">img_targets</span><span class="p">,</span>
                <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Filter the visible targets</span>
            <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span> <span class="o">=</span> <span class="n">filter_one2one</span><span class="p">(</span>
                <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">num_matches</span> <span class="o">&gt;</span> <span class="n">max_num_matches</span><span class="p">:</span>
                <span class="n">max_num_matches</span> <span class="o">=</span> <span class="n">num_matches</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\t</span><span class="s2">max number of matches found:&quot;</span><span class="p">,</span> <span class="n">num_matches</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t\t\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">max_rmat</span><span class="p">,</span> <span class="n">max_tvec</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span>

            <span class="c1"># If there are enough matches, repeat checking process with vis_checker</span>
            <span class="c1">#   to ensure this solution is valid</span>
            <span class="k">if</span> <span class="n">num_matches</span> <span class="o">&gt;=</span> <span class="n">match_thresh</span><span class="p">:</span>
                <span class="c1"># Get the visible targets</span>
                <span class="n">tgts_vis</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">get_visible_targets</span><span class="p">(</span>
                    <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span>
                <span class="p">)</span>

                <span class="c1"># Match the visible targets</span>
                <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span> <span class="o">=</span> <span class="n">match_targets</span><span class="p">(</span>
                    <span class="n">rmat</span><span class="p">,</span>
                    <span class="n">tvec</span><span class="p">,</span>
                    <span class="n">cameraMatrix</span><span class="p">,</span>
                    <span class="n">distCoeffs</span><span class="p">,</span>
                    <span class="n">tgts_vis</span><span class="p">,</span>
                    <span class="n">img_targets</span><span class="p">,</span>
                    <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Filter the visible targets</span>
                <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span> <span class="o">=</span> <span class="n">filter_one2one</span><span class="p">(</span>
                    <span class="n">tgts_matched</span><span class="p">,</span> <span class="n">matching_points</span><span class="p">,</span> <span class="n">num_matches</span>
                <span class="p">)</span>

                <span class="c1"># Package the target tvecs and image points</span>
                <span class="n">tgt_tvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">tgts_matched</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;tvec&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">img_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">matching_points</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_matches</span><span class="p">)]</span>
                <span class="p">)</span>

                <span class="c1"># SolvePnP but with all targets</span>
                <span class="n">retval</span><span class="p">,</span> <span class="n">rvec_opt</span><span class="p">,</span> <span class="n">tvec_opt</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">solvePnP</span><span class="p">(</span>
                    <span class="n">tgt_tvecs</span><span class="p">,</span>
                    <span class="n">img_centers</span><span class="p">,</span>
                    <span class="n">cameraMatrix</span><span class="p">,</span>
                    <span class="n">distCoeffs</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tvec</span><span class="p">),</span>
                    <span class="n">useExtrinsicGuess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rvec_opt</span><span class="p">)</span>

                <span class="c1"># If there are still enough matches, return the solution found</span>
                <span class="c1">#   Otherwise just go back into the loop</span>
                <span class="k">if</span> <span class="n">num_matches</span> <span class="o">&gt;=</span> <span class="n">match_thresh</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">rmat_opt</span><span class="p">,</span> <span class="n">tvec_opt</span>

        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">warn_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span>
        <span class="s2">&quot;Maximum number of iterations exceeded in &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;external_calibrate_RANSAC. Please check that inputs are correct. &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;If they are, increase max_iter, increase max_dist, or decrease &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;match_thresh. Returning the best found solution&quot;</span>
    <span class="p">)</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_str</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_rmat</span><span class="p">,</span> <span class="n">max_tvec</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, uPSP Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>