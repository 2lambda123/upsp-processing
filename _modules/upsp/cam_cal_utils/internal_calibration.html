
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>upsp.cam_cal_utils.internal_calibration &#8212; uPSP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">uPSP</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file-formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Third-Party Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../swdd.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../known-issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing this work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_apidoc/upsp.html"><code class="docutils literal notranslate"><span class="pre">upsp</span></code> Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for upsp.cam_cal_utils.internal_calibration</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="kn">from</span> <span class="nn">upsp.cam_cal_utils</span> <span class="kn">import</span> <span class="n">photogrammetry</span><span class="p">,</span> <span class="n">parsers</span><span class="p">,</span> <span class="n">visualization</span>

<span class="n">debug_show_cal_bounds</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">meter2inch</span> <span class="o">=</span> <span class="mf">39.3701</span>

<span class="c1"># NOTE: This is implemented for Calib.io version v1.6.5a</span>


<div class="viewcode-block" id="get_safe_pts"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.get_safe_pts">[docs]</a><span class="k">def</span> <span class="nf">get_safe_pts</span><span class="p">(</span>
    <span class="n">rmat</span><span class="p">,</span>
    <span class="n">tvec</span><span class="p">,</span>
    <span class="n">cameraMatrix</span><span class="p">,</span>
    <span class="n">distCoeffs</span><span class="p">,</span>
    <span class="n">obj_pts</span><span class="p">,</span>
    <span class="n">cal_area_is_safe</span><span class="p">,</span>
    <span class="n">cal_vol_is_safe</span><span class="p">,</span>
    <span class="n">critical_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines which `obj_pts` are inside the well behaved region of the internal calibration</span>

<span class="sd">    Performs 3 checks on each of the `obj_pts`. The first check and second check is that</span>
<span class="sd">    each obj_pt and its projection are within the safe volume and safe area as defined</span>
<span class="sd">    by cal_area_is_safe and cal_vol_is_safe. These checks are always performed. The</span>
<span class="sd">    third check is not always necessary, and is more involved.</span>

<span class="sd">    If the highest order (non-zero) radial distortion term of `distCoeffs` is negative,</span>
<span class="sd">    then at some real world distance from the camera optical axis, increasing the real</span>
<span class="sd">    world distance from the camera optical axis will decrease pixel distance of that</span>
<span class="sd">    point&#39;s projection. I.e. moving farther out of frame will move the point closer to</span>
<span class="sd">    the image center. This is not a bug, but is not an accurate model of the physical</span>
<span class="sd">    system. This means that some object points very far out of the field of view can</span>
<span class="sd">    be projected into the frame. These points have a &#39;negative derivative&#39; of the</span>
<span class="sd">    projection curve. As the input (real world distance from camera optical axis)</span>
<span class="sd">    increases, the output (projected distance from the image center) decreases.</span>

<span class="sd">    The points need not be outside the field of view to have a negative derivative. So a</span>
<span class="sd">    simple FOV check is unfortunately insufficient. The third check is unnecessary if</span>
<span class="sd">    `cal_area_is_safe` and `cal_vol_is_safe` are well constructed. If they are not well</span>
<span class="sd">    constructed, the third check ensures the object points are in the well-behaved</span>
<span class="sd">    region of the internal calibration. For most cases, this means the object points</span>
<span class="sd">    are in the positive region of the internal calibration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (5, 1) or (5,), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    obj_pts : np.ndarray, shape (n, 3), float</span>
<span class="sd">        List of 3d points. Points are relative to the object frame</span>
<span class="sd">    cal_area_is_safe : callable</span>
<span class="sd">        ``alpha_shape_is_safe`` function that takes `img_pts` as an array, (shape</span>
<span class="sd">        ``(n, 2)``) of floats and returns an array-like object of booleans.</span>
<span class="sd">        ``return[i]`` corresonds to ``img_pts[i]``. If ``return[i]`` is True, then</span>
<span class="sd">        ``img_pts[i]`` is within the safe internal calibration image area. If it is</span>
<span class="sd">        False, it is not within that safe area</span>
<span class="sd">    cal_vol_is_safe : callable</span>
<span class="sd">        ``alpha_shape_is_safe`` function that takes `obj_pts` and returns a array-like</span>
<span class="sd">        object of booleans. ``return[i]`` corresonds to ``img_pts[i]``. If ``return[i]``</span>
<span class="sd">        is True, then ``img_pts[i]`` is within the safe internal calibration 3D volume.</span>
<span class="sd">        If it is False, it is not within that safe volume</span>
<span class="sd">    critical_pt : str, optional</span>
<span class="sd">        Criteria for step 3. Must be one of:</span>

<span class="sd">        - If &#39;first&#39; then `obj_pts` cannot have a homogeneous coordinate with a</span>
<span class="sd">          magnitude past the first maxima of the distortion curve. This is the most</span>
<span class="sd">          useful option for the majority of lenses.</span>
<span class="sd">        - If &#39;infinity&#39;, the magnitude must be less than the final maxima of the</span>
<span class="sd">          distortion curve, and the distortion curve must be decreasing after the final</span>
<span class="sd">          maxima. This is the most useful option for mustache or otherwise complex</span>
<span class="sd">          distortion, if the mustache distortion effect is accurate</span>
<span class="sd">        - If ``None``, step 3 will be omitted. If `cal_area_is_safe` and</span>
<span class="sd">          `cal_vol_is_safe` are available (and not dummy return True functions from</span>
<span class="sd">          :func:`incal_calibration_bounds_debug`), the step 3 check is likely</span>
<span class="sd">          unnecessary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj_pts_safe : np.ndarray, shape (n,), bool</span>
<span class="sd">        Array of booleans where ``return[i]`` cooresponds to ``obj_pts[i]``. If</span>
<span class="sd">        ``return[i]`` is True, ``obj_pts[i]`` is well behaved. If ``return[i]`` is</span>
<span class="sd">        False, ``obj_pts[i]`` may not be well behaved</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    incal_calibration_bounds : creates ``alpha_shape_is_safe`` functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">critical_pt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;final&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="c1"># Define a list of booleans to denote if a variable is safe</span>
    <span class="n">obj_pts_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj_pts</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Step 1: Check that the points project to within the safe image area region</span>
    <span class="n">img_pts</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">project_3d_point</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">obj_pts</span>
    <span class="p">)</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">cal_area_is_safe</span><span class="p">(</span><span class="n">img_pts</span><span class="p">)</span>

    <span class="c1"># Step 2: Check that the points are within the safe 3D volume</span>
    <span class="n">pts_rel_cam</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">transform_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">obj_pts</span><span class="p">)</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">cal_vol_is_safe</span><span class="p">(</span><span class="n">pts_rel_cam</span><span class="p">)</span>

    <span class="c1"># Step 3a: Check for shortcuts to determine if the full step 3 is necessary</span>

    <span class="c1"># First shortcut skips if step 3 is omitted</span>
    <span class="k">if</span> <span class="n">critical_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj_pts_safe</span>

    <span class="c1"># Second shortcut skips if all of the distortion coefficients are non-negative,</span>
    <span class="c1">#   since there is no maxima</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distCoeffs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">obj_pts_safe</span>

    <span class="c1"># Third shortcut skips if critical_pt == &#39;final&#39; and the projection curve has a</span>
    <span class="c1">#   positive derivative as the magnitude of the homogeneous coordinates goes to inf</span>
    <span class="c1"># To determine that, we find the highest order, nonzero term. The highest order term</span>
    <span class="c1">#   for both the x projected position and y projected position is k3, then k2, then</span>
    <span class="c1">#   k1. After that, the highest order term for the x projected position is p2 and</span>
    <span class="c1">#   the highest order term for the y projected position is p1. Since step 2 checked</span>
    <span class="c1">#   for no distortion, if k3, k2, and k1 are zero then p1 or (or both) p2 must be</span>
    <span class="c1">#   nonzero. If the minimum of those 2 is positive, they are both positive. After p1</span>
    <span class="c1">#   and p2, The remainining terms are linear and a constant offset. Neither of which</span>
    <span class="c1">#   cause the issue step 3 addresses so neither need to be checked.</span>
    <span class="n">highest_nonzero_term</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span>
        <span class="k">else</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span>
        <span class="k">else</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span>
        <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">critical_pt</span> <span class="o">==</span> <span class="s2">&quot;final&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">highest_nonzero_term</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj_pts_safe</span>

    <span class="c1"># Step 3b: Perform the full step 3</span>

    <span class="c1"># First step is to get the location of the points relative to the camera.</span>
    <span class="n">obj_pts_rel_cam</span> <span class="o">=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">transform_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">obj_pts</span><span class="p">)</span>

    <span class="c1"># Define the homogenous coordiantes</span>
    <span class="n">x_homo_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">obj_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">y_homo_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">obj_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c1"># Define the distortion terms, and vectorize calculating of powers of x_homo_vals</span>
    <span class="c1">#   and y_homo_vals</span>
    <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">k3</span> <span class="o">=</span> <span class="n">distCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x_homo_vals_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">y_homo_vals_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">x_homo_vals_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">y_homo_vals_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">x_homo_vals_6</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">y_homo_vals_6</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="c1"># This step cannot be vectorized since the numpy roots function is numerical</span>
    <span class="c1"># Find the bounds on the x_homo coordinate to ensure it is closer than the</span>
    <span class="c1">#   inflection point of x_proj as a function of x_homo</span>
    <span class="n">x_homo_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">x_homo_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="p">)):</span>
        <span class="c1"># If obj_pts_safe[i] is False already, no need to calculate the roots</span>
        <span class="k">if</span> <span class="n">obj_pts_safe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Expanded projection function polynomial coefficients</span>
        <span class="n">x_proj_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">k3</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">k2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">y_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">y_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">y_homo_vals_4</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="mi">3</span> <span class="o">*</span> <span class="n">p2</span><span class="p">,</span>
                <span class="mi">1</span>
                <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">y_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">y_homo_vals_4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">y_homo_vals_6</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">y_homo_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">p2</span> <span class="o">*</span> <span class="n">y_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Projection function derivative polynomial coefficients</span>
        <span class="n">x_proj_der_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">x_proj_coeffs</span><span class="p">)</span>

        <span class="c1"># Find the root of the derivative</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">x_proj_der_coeffs</span><span class="p">)</span>

        <span class="c1"># Get the real roots</span>
        <span class="c1"># Approximation of real[np.where(np.isreal(roots))]</span>
        <span class="n">real_roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">roots</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">real_root</span> <span class="ow">in</span> <span class="n">real_roots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">critical_pt</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">real_root</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">x_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
                <span class="n">x_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>

    <span class="c1"># Check that the x_homo values are within the bounds</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_homo_vals</span> <span class="o">&gt;</span> <span class="n">x_homo_min</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_homo_vals</span> <span class="o">&lt;</span> <span class="n">x_homo_max</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Find the bounds on the y_homo coordinate to ensure it is closer than the</span>
    <span class="c1">#   inflection point of y_proj as a function of y_homo</span>
    <span class="n">y_homo_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">y_homo_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">y_homo_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_homo_vals</span><span class="p">)):</span>
        <span class="c1"># If obj_pts_safe[i] is False already, no need to calculate the roots</span>
        <span class="k">if</span> <span class="n">obj_pts_safe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Expanded projection function polynomial coefficients</span>
        <span class="n">y_proj_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">k3</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">k2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">x_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">x_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">x_homo_vals_4</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="mi">3</span> <span class="o">*</span> <span class="n">p1</span><span class="p">,</span>
                <span class="mi">1</span>
                <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">x_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">x_homo_vals_4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">x_homo_vals_6</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">x_homo_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">p1</span> <span class="o">*</span> <span class="n">x_homo_vals_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Projection function derivative polynomial coefficients</span>
        <span class="n">y_proj_der_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">y_proj_coeffs</span><span class="p">)</span>

        <span class="c1"># Find the root of the derivative</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">y_proj_der_coeffs</span><span class="p">)</span>

        <span class="c1"># Get the real roots</span>
        <span class="c1"># Approximation of real[np.where(np.isreal(roots))]</span>
        <span class="n">real_roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">roots</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">real_root</span> <span class="ow">in</span> <span class="n">real_roots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">critical_pt</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">real_root</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">y_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_homo_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>
                <span class="n">y_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_homo_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real_root</span><span class="p">)</span>

    <span class="c1"># Check that the x_homo values are within the bounds</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_homo_vals</span> <span class="o">&gt;</span> <span class="n">y_homo_min</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">obj_pts_safe</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_homo_vals</span> <span class="o">&lt;</span> <span class="n">y_homo_max</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Return the list of is_safe booleans</span>
    <span class="k">return</span> <span class="n">obj_pts_safe</span></div>


<div class="viewcode-block" id="incal_from_calibio"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.incal_from_calibio">[docs]</a><span class="k">def</span> <span class="nf">incal_from_calibio</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the internal calibration values from the calib.io output json</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calibio_path : str</span>
<span class="sd">        Path to the calib.io saved calibration json</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    img_size : np.ndarray, shape (2,)</span>
<span class="sd">        Image size (height, width)</span>
<span class="sd">    uPSP_cameraMatrix : np.ndarray, shape (3, 3)</span>
<span class="sd">        Camera matrix for uPSP applications (same as openCV ``cameraMatrix``, but cx and</span>
<span class="sd">        cy are vectors from image center to principal point rather than the principal</span>
<span class="sd">        point itself).</span>
<span class="sd">    distCoeffs : np.ndarray, shape (5, 1)</span>
<span class="sd">        openCV distortion coefficients</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the internal calibration data</span>
    <span class="n">calibio_data</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)[</span><span class="s2">&quot;calibration&quot;</span><span class="p">][</span><span class="s2">&quot;cameras&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
        <span class="s2">&quot;model&quot;</span>
    <span class="p">][</span><span class="s2">&quot;ptr_wrapper&quot;</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>

    <span class="c1"># Get the image size</span>
    <span class="n">img_size</span> <span class="o">=</span> <span class="n">calibio_data</span><span class="p">[</span><span class="s2">&quot;CameraModelCRT&quot;</span><span class="p">][</span><span class="s2">&quot;CameraModelBase&quot;</span><span class="p">][</span><span class="s2">&quot;imageSize&quot;</span><span class="p">]</span>
    <span class="n">img_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">img_size</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]))</span>

    <span class="c1"># Read the internal calibration parameters</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">calibio_data</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span>

    <span class="c1"># Parse the camera matrix</span>
    <span class="n">cameraMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;cx&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;cy&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">uPSP_cameraMatrix</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">convert_cv2_cm_to_uPSP_cm</span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span>

    <span class="c1"># Parse the distortion coefficients</span>
    <span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;k1&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;k2&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;p1&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;p2&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;k3&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">img_size</span><span class="p">,</span> <span class="n">uPSP_cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span></div>


<div class="viewcode-block" id="write_incal_from_calibio"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.write_incal_from_calibio">[docs]</a><span class="k">def</span> <span class="nf">write_incal_from_calibio</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">,</span> <span class="n">camera_name</span><span class="p">,</span> <span class="n">sensor_size</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Writes the internal calibration to a json file</span>

<span class="sd">    Saves internal calibration as ``&#39;{camera_name}.json&#39;`` to `save_dir`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calibio_path : str</span>
<span class="sd">        Path to the calib.io saved calibration json</span>
<span class="sd">    camera_name : str</span>
<span class="sd">        Name of the camera</span>
<span class="sd">    sensor_size : np.ndarray, shape (2,) of floats</span>
<span class="sd">        Physical size of the image sensor in inches</span>
<span class="sd">    save_dir : str, optional</span>
<span class="sd">        Path of directory to save the internal calibration json file. If None, save_dir</span>
<span class="sd">        is set to the directory containing the Calib.io json</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_size</span><span class="p">,</span> <span class="n">uPSP_cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">incal_from_calibio</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)</span>
    <span class="n">sensor_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sensor_size</span><span class="p">)</span>

    <span class="n">incal</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;uPSP_cameraMatrix&quot;</span><span class="p">:</span> <span class="n">uPSP_cameraMatrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;distCoeffs&quot;</span><span class="p">:</span> <span class="n">distCoeffs</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;sensor_resolution&quot;</span><span class="p">:</span> <span class="n">img_size</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;sensor_size&quot;</span><span class="p">:</span> <span class="n">sensor_size</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">save_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)</span>

    <span class="c1"># Export the internal calibration as a json file</span>
    <span class="n">cal_file</span> <span class="o">=</span> <span class="n">camera_name</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">cal_file</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">incal</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="uncertainties_from_calibio"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.uncertainties_from_calibio">[docs]</a><span class="k">def</span> <span class="nf">uncertainties_from_calibio</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns uncertainties for OpenCV terms</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calibio_path : str</span>
<span class="sd">        Path to the calib.io saved calibration json</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Standard deviation of calibration terms: (focal length, principal point x,</span>
<span class="sd">        principal point y, k1, k2, p1, p2, k3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">covariance_data</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)[</span><span class="s2">&quot;covariance&quot;</span><span class="p">][</span><span class="s2">&quot;covarianceMatrix&quot;</span><span class="p">]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">covariance_data</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">][</span><span class="s2">&quot;height&quot;</span><span class="p">],</span> <span class="n">covariance_data</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>
    <span class="n">covarianceMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">covariance_data</span><span class="p">[</span><span class="s2">&quot;pixels&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="n">f_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">cx_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">cy_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">k1_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">k2_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">p1_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">])</span>
    <span class="n">p2_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">11</span><span class="p">])</span>
    <span class="n">k3_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covarianceMatrix</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">6</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">f_stddev</span><span class="p">,</span>
        <span class="n">cx_stddev</span><span class="p">,</span>
        <span class="n">cy_stddev</span><span class="p">,</span>
        <span class="n">k1_stddev</span><span class="p">,</span>
        <span class="n">k2_stddev</span><span class="p">,</span>
        <span class="n">p1_stddev</span><span class="p">,</span>
        <span class="n">p2_stddev</span><span class="p">,</span>
        <span class="n">k3_stddev</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="incal_calibration_bounds"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.incal_calibration_bounds">[docs]</a><span class="k">def</span> <span class="nf">incal_calibration_bounds</span><span class="p">(</span>
    <span class="n">calibio_path</span><span class="p">,</span> <span class="n">cal_vol_alpha</span><span class="p">,</span> <span class="n">cal_area_alpha</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_vol_figs</span><span class="o">=</span><span class="mi">10</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates objects that determines if a point is inside the calibration regions</span>

<span class="sd">    From the `calibio_path`, the 3D points from the calibration board are used to define</span>
<span class="sd">    the safe 3D volume. The 2D points of the image detections are used to define the</span>
<span class="sd">    safe image area. The area/volume are defined using an alpha shape (technically an</span>
<span class="sd">    alpha complex). An alpha shape is similar to a convex hull, but sets a limit on the</span>
<span class="sd">    distance between two vertices for them to be connected. The max distances for the</span>
<span class="sd">    volume and area is 1 / `cal_vol_alpha` and  1 / `cal_area_alpha` respectively.</span>

<span class="sd">    If the global variable `debug_show_cal_bounds` is True, this method also creates</span>
<span class="sd">    debug images.</span>

<span class="sd">    One debug image is created for the safe image area. That image is green for pixels</span>
<span class="sd">    inside the &#39;safe&#39; region and red for pixels outside the safe region. The region is</span>
<span class="sd">    not discretized to pixels, so the image is a (good) approximation.</span>

<span class="sd">    Several debug images are created for the safe 3D volume. Each debug image is a slice</span>
<span class="sd">    of the 3D safe object. The slices are done at planes progressively farther from the</span>
<span class="sd">    camera (not spherical shells of constant distance from the camera). Points in the</span>
<span class="sd">    field of view (not accounting for lens distortion) are given. Points colored red are</span>
<span class="sd">    unsafe. Points colored green are safe.</span>

<span class="sd">    Generates the following images when `debug_show_cal_bounds` (global) is True:</span>

<span class="sd">        ``3d_cal_points_camera.png``</span>
<span class="sd">            A scatter plot of the internal calibration points as viewed from the camera</span>
<span class="sd">            position. X is the real world position relative to the camera horizontal</span>
<span class="sd">            axis. Z is the real world position relative to the camera optical axis.</span>
<span class="sd">        ``3d_cal_points_side.png``</span>
<span class="sd">            A scatter plot of the internal calibration points as viewed from a location</span>
<span class="sd">            to the side of the camera. X is the real world position relative to the</span>
<span class="sd">            camera horizontal axis. Y is the real world position relative to the camera</span>
<span class="sd">            vertical axis.</span>
<span class="sd">        ``image_area.png``</span>
<span class="sd">            The safe and unsafe locations in the image based on the internal calibration</span>
<span class="sd">            points and the cal_area_alpha parameter</span>
<span class="sd">        ``unsafe_volume_Z=*_inches.png``</span>
<span class="sd">            Where * is Z location of the planar slice in inches for the given image.</span>
<span class="sd">            These images are like a wedding cake stack of the 3D calibration volume.</span>
<span class="sd">            Each image is a slice of the volume at a given Z distance from the camera.</span>
<span class="sd">            The image shows the safe and unsafe locations in that planar slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calibio_path : str</span>
<span class="sd">        Path to the calib.io saved calibration json</span>
<span class="sd">    cal_vol_alpha : float</span>
<span class="sd">        Used to define the 3D volume alpha shape. Alpha parameter is 1 / `cal_vol_alpha`</span>
<span class="sd">    cal_area_alpha : float</span>
<span class="sd">        Used to define the 3D image area alpha shape. Alpha parameter is 1 /</span>
<span class="sd">        `cal_vol_alpha`</span>
<span class="sd">    dof : tuple, optional</span>
<span class="sd">        Depth of field. Optional, but must be given if global variable</span>
<span class="sd">        `debug_show_cal_bounds` is True since it is used to generate debug images. The</span>
<span class="sd">        first item of tuple is distance to the first slice of the 3D volume. The second</span>
<span class="sd">        item is distance to the last slice. The slices are done in planes (not in</span>
<span class="sd">        spherical shells of constant distance to the camera).</span>
<span class="sd">    num_vol_figs : int, optional</span>
<span class="sd">        Number of volume figures. Optional, but must be given if global variable</span>
<span class="sd">        `debug_show_cal_bounds` is True since it is used to generate debug images.  The</span>
<span class="sd">        debug images of the calibration volume slice the volume into planes at</span>
<span class="sd">        progressively farther distances. This input determines the number of slices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cal_area_is_safe : callable</span>
<span class="sd">        Function that takes image points in an array-like object and returns a</span>
<span class="sd">        corresponding array of bools indicating which points are safe.</span>
<span class="sd">    cal_vol_is_safe : callable</span>
<span class="sd">        Function that takes 3D points in an array-like object and returns a</span>
<span class="sd">        corresponding array of bools indicating which points are safe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the debug_show_cal_bounds is True, dof is required</span>
    <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="n">debug_show_cal_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">debug_show_cal_bounds</span> <span class="ow">and</span> <span class="n">dof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">calibio</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)</span>

    <span class="c1"># Read in the internal calibration from the file</span>
    <span class="n">img_size</span><span class="p">,</span> <span class="n">uPSP_cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">incal_from_calibio</span><span class="p">(</span><span class="n">calibio_path</span><span class="p">)</span>
    <span class="n">cameraMatrix</span> <span class="o">=</span> <span class="n">parsers</span><span class="o">.</span><span class="n">convert_uPSP_cm_to_cv2_cm</span><span class="p">(</span><span class="n">uPSP_cameraMatrix</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span>

    <span class="c1"># Define the calibrated image area</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">calibio</span><span class="p">[</span><span class="s2">&quot;detections&quot;</span><span class="p">]</span>
    <span class="n">img_pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
        <span class="n">featurePoints</span> <span class="o">=</span> <span class="n">detection</span><span class="p">[</span><span class="s2">&quot;featurePoints&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">featurePoints</span><span class="p">:</span>
            <span class="n">img_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pt</span><span class="p">[</span><span class="s2">&quot;point&quot;</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="s2">&quot;point&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]))</span>

    <span class="n">img_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_pts</span><span class="p">)</span>
    <span class="n">cal_area_is_safe</span> <span class="o">=</span> <span class="n">alpha_shape_is_safe</span><span class="p">(</span><span class="n">img_pts</span><span class="p">,</span> <span class="n">cal_area_alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug_show_cal_bounds</span><span class="p">:</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="n">pixel_bools</span> <span class="o">=</span> <span class="n">cal_area_is_safe</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        <span class="n">unsafe_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">pixel_bools</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">safe_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pixel_bools</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">unsafe_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">unsafe_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Unsafe&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">safe_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">safe_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Safe&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">img_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">img_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Calibration Points&quot;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X (pixels)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y (pixels)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;image_area.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>

    <span class="c1"># Get the calibration target positions relative to the board frame</span>
    <span class="n">cal_pts_metric</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cal_pt_metric</span> <span class="ow">in</span> <span class="n">calibio</span><span class="p">[</span><span class="s2">&quot;targets&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;objectPoints&quot;</span><span class="p">]:</span>
        <span class="n">cal_pts_metric</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="n">cal_pt_metric</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">cal_pt_metric</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">cal_pt_metric</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]]</span>
        <span class="p">)</span>
    <span class="n">cal_pts_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cal_pts_metric</span><span class="p">)</span>
    <span class="n">cal_pts</span> <span class="o">=</span> <span class="n">cal_pts_metric</span> <span class="o">*</span> <span class="n">meter2inch</span>

    <span class="c1"># Get the locations of all 3D targets</span>
    <span class="n">poses</span> <span class="o">=</span> <span class="n">calibio</span><span class="p">[</span><span class="s2">&quot;calibration&quot;</span><span class="p">][</span><span class="s2">&quot;poses&quot;</span><span class="p">]</span>
    <span class="n">cal_pts_rel_cam</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pose</span> <span class="ow">in</span> <span class="n">poses</span><span class="p">:</span>
        <span class="n">transformation</span> <span class="o">=</span> <span class="n">pose</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span>

        <span class="c1"># Get the rotation matrix from the quaternions</span>
        <span class="n">rvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">][</span><span class="s2">&quot;rx&quot;</span><span class="p">],</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">][</span><span class="s2">&quot;ry&quot;</span><span class="p">],</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">][</span><span class="s2">&quot;rz&quot;</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span>

        <span class="c1"># Get the translation vector</span>
        <span class="n">tvec_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;translation&quot;</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;translation&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">],</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;translation&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">tvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">tvec_metric</span> <span class="o">*</span> <span class="n">meter2inch</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">cal_pts_rel_cam</span> <span class="o">+=</span> <span class="n">photogrammetry</span><span class="o">.</span><span class="n">transform_3d_point</span><span class="p">(</span>
            <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cal_pts</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">cal_pts_rel_cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cal_pts_rel_cam</span><span class="p">)</span>
    <span class="n">cal_vol_is_safe</span> <span class="o">=</span> <span class="n">alpha_shape_is_safe</span><span class="p">(</span><span class="n">cal_pts_rel_cam</span><span class="p">,</span> <span class="n">cal_vol_alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug_show_cal_bounds</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">cal_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">cal_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">cal_pts_rel_cam</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">depthshade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;X (inches)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Y (inches)&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=-</span><span class="mf">90.0</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">visualization</span><span class="o">.</span><span class="n">axisEqual3D</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;3d_cal_points_ceiling.png&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s2">&quot;Z (inches)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;3d_cal_points_camera.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug_show_cal_bounds</span><span class="p">:</span>
        <span class="n">pixel_extremes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">pixels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]))),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">pixels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]))),</span>
        <span class="p">]</span>
        <span class="n">max_reach</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pixel_extremes</span><span class="p">)</span> <span class="o">/</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dof</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">max_reach</span> <span class="o">*=</span> <span class="mf">1.1</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dof</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dof</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_vol_figs</span><span class="p">):</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">cameraMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="n">pt_bools</span> <span class="o">=</span> <span class="n">cal_vol_is_safe</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">unsafe_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">pt_bools</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">safe_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pt_bools</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">unsafe_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">unsafe_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">unsafe_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">depthshade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Unsafe&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">safe_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">safe_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">safe_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">depthshade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Safe&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">max_reach</span><span class="p">,</span> <span class="n">max_reach</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">max_reach</span><span class="p">,</span> <span class="n">max_reach</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=-</span><span class="mf">90.0</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
            <span class="n">visualization</span><span class="o">.</span><span class="n">axisEqual3D</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

            <span class="n">digits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dof</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">fig_idx</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">digits</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X (inches)&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y (inches)&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;unsafe_volume_Z=&quot;</span> <span class="o">+</span> <span class="n">fig_idx</span> <span class="o">+</span> <span class="s2">&quot;_inches.png&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cal_area_is_safe</span><span class="p">,</span> <span class="n">cal_vol_is_safe</span></div>


<div class="viewcode-block" id="incal_calibration_bounds_debug"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.incal_calibration_bounds_debug">[docs]</a><span class="k">def</span> <span class="nf">incal_calibration_bounds_debug</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns debugging :func:`incal_calibration_bounds` objects</span>

<span class="sd">    The returned :func:`incal_calibration_bounds` functions True for every input point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_always_safe</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_always_safe</span><span class="p">,</span> <span class="n">is_always_safe</span></div>


<div class="viewcode-block" id="alpha_shape_is_safe"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.internal_calibration.html#upsp.cam_cal_utils.internal_calibration.alpha_shape_is_safe">[docs]</a><span class="k">def</span> <span class="nf">alpha_shape_is_safe</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns an alpha shape generated from points and the `alpha` parameter</span>

<span class="sd">    Returns an alpha shape constructed from the points and the given alpha parameters.</span>
<span class="sd">    An alpha shape is similar to a convex hull, but sets a maximum on the distance</span>
<span class="sd">    between two vertices. The distances is 1 / `alpha`. An alpha shape is a convex hull</span>
<span class="sd">    if the alpha parameter is 0.</span>

<span class="sd">    The shape may be more accurately referred to as an alpha complex (rather than alpha</span>
<span class="sd">    shape) since it has poligonal edges, but many sources use alpha shape to refer to</span>
<span class="sd">    both.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts : np.ndarray, shape (n, k) of floats</span>
<span class="sd">        Calibration points to create the alpha shape from. ``n`` is the number of points</span>
<span class="sd">        ``k`` is the dimensionality of the points (2 for image points, 3 for real world</span>
<span class="sd">        points)</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Alpha parameter of the alpha shape. Larger means more points are rejected. Must</span>
<span class="sd">        be non-negative. Negative values are clipped to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_safe : callable</span>
<span class="sd">        Function that accepts an array-like object (list, np.array, etc) of points and</span>
<span class="sd">        returns a list of booleans of the same length. ``return[i]`` corresponds to</span>
<span class="sd">        ``point[i]`` and True means that point is inside the alpha shape (False means it</span>
<span class="sd">        is not).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For numerical stability, clip alpha to a very small value</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mf">1e-30</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Get the Delaunay tessellation of the pts</span>
    <span class="n">tess</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

    <span class="c1"># Scipy Delaunay returns tessellation as incides, get tessellation as points</span>
    <span class="n">tess_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">tess</span><span class="o">.</span><span class="n">simplices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Get the number of dimensions</span>
    <span class="n">num_dims</span> <span class="o">=</span> <span class="n">tess</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Get the radius of the circumsphere (circumcircle in 2D) for each of the tessellation</span>
    <span class="c1"># Equations for circumcircle and circumsphere radius from wolframalpha:</span>
    <span class="c1">#   https://mathworld.wolfram.com/Circumcircle.html</span>
    <span class="c1">#   https://mathworld.wolfram.com/Circumsphere.html</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">tess_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tess_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tess_pts</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tess_pts</span><span class="p">,</span> <span class="n">ones</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">normsq</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">a_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">c_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">det_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dims</span><span class="p">):</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_dims</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">D_k</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">det_sum</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">D_k</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Calculate the discriminant</span>
    <span class="c1"># Clip values that are negative due to machine precision</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">det_sum</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a_det</span> <span class="o">*</span> <span class="n">c_det</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="p">(</span><span class="n">disc</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
        <span class="n">disc</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Calculate the denominator, but clip the abs value of a_det to avoid 0/0 issues</span>
    <span class="c1"># a_det is clipped 10 orders of magnitude larger than disc so 0/0 = 0</span>
    <span class="c1">#   That way 0/0 tessellations are rejected</span>
    <span class="n">den</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a_det</span><span class="p">),</span> <span class="mf">1e-20</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Calculate the radius of each Delaunay tessellation</span>
    <span class="n">tess_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">disc</span><span class="p">),</span> <span class="n">den</span><span class="p">)</span>

    <span class="c1"># Get a set of the indices of the tessellation that are a part of the alpha shape</span>
    <span class="n">alpha_shape_tess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tess_radii</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Return a fuction that determines if a point is safe</span>
    <span class="c1">#   is_safe returns True if the point is inside the alpha shape boundary, and</span>
    <span class="c1">#   returns False if it is outside the alpha shape boundary</span>
    <span class="k">def</span> <span class="nf">is_safe</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>
        <span class="c1"># Find the simplex that contains the point (if it exists)</span>
        <span class="n">simplex_idx</span> <span class="o">=</span> <span class="n">tess</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="c1"># Check if the index is in the set of safe indexes</span>
        <span class="c1">#   If it is, return True. Otherwise return False</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">simplex_idx</span><span class="p">,</span> <span class="n">alpha_shape_tess</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Return the is_safe function</span>
    <span class="k">return</span> <span class="n">is_safe</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, uPSP Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>