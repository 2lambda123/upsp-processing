
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>upsp.cam_cal_utils.photogrammetry &#8212; uPSP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">uPSP</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file-formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Third-Party Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../swdd.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../known-issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing this work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_apidoc/upsp.html"><code class="docutils literal notranslate"><span class="pre">upsp</span></code> Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for upsp.cam_cal_utils.photogrammetry</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">scipy_Rotation</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

<span class="c1">#---------------------------------------------------------------------------------------</span>
<span class="c1"># General Photogrammetry Utility Functions</span>


<div class="viewcode-block" id="rot"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.rot">[docs]</a><span class="k">def</span> <span class="nf">rot</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotation matrix for angle-axis transformation</span>

<span class="sd">    An identity matrix is rotated about the given axis by the given angle (in degrees)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angle : float</span>
<span class="sd">        angle of rotation (in degrees) about the given axis</span>
<span class="sd">    axis : {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}</span>
<span class="sd">        axis to rotate about</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix of an identity matrix rotated about the given axis by the given</span>
<span class="sd">        amount</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">assert_error_msg</span> <span class="o">=</span> <span class="s2">&quot;Error in photogrammetry.rot. Axis must be &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;.&quot;</span>
    <span class="k">assert</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">assert_error_msg</span>

    <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>                 <span class="mi">0</span><span class="p">,</span>                  <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)]])</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                  <span class="mi">1</span><span class="p">,</span>                   <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">)]])</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                  <span class="mi">0</span><span class="p">,</span>                 <span class="mi">1</span><span class="p">]])</span></div>


<div class="viewcode-block" id="invTransform"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.invTransform">[docs]</a><span class="k">def</span> <span class="nf">invTransform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the inverse transformation of the given `R` and `t`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation Matrix</span>
<span class="sd">    t : np.ndarray (3, 1), float</span>
<span class="sd">        Translation Vector</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat_i : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Inverse rotation matrix</span>
<span class="sd">    tvec_i : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Inverse translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">R_transpose</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">R_transpose</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">R_transpose</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span></div>


<div class="viewcode-block" id="isRotationMatrix"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.isRotationMatrix">[docs]</a><span class="k">def</span> <span class="nf">isRotationMatrix</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if a matrix is a valid rotation matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation Matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    bool</span>
<span class="sd">        True if R is a valid rotation matrix, and False if it is not</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Rt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">shouldBeIdentity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rt</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-</span> <span class="n">shouldBeIdentity</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mf">1e-6</span></div>


<div class="viewcode-block" id="isRotationMatrixRightHanded"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.isRotationMatrixRightHanded">[docs]</a><span class="k">def</span> <span class="nf">isRotationMatrixRightHanded</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns True if matrix is right handed, and False it is not</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : np.ndarray (3, 3), float</span>
<span class="sd">        Rotation Matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    boolean</span>
<span class="sd">        True if R is a right handed rotation matrix, and False if it is not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">R</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.</span></div>


<div class="viewcode-block" id="rotationMatrixToTunnelAngles"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.rotationMatrixToTunnelAngles">[docs]</a><span class="k">def</span> <span class="nf">rotationMatrixToTunnelAngles</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts rotation matrix to tunnel angles</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation Matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray (3, 1), float</span>
<span class="sd">        Array of tunnel angle (alpha, beta, phi)</span>

<span class="sd">    See Also</span>
<span class="sd">    ----------</span>
<span class="sd">    isRotationMatrix : Checks if a matrix is a valid rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that the given matrix is a valid roation matrix</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">isRotationMatrix</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

    <span class="c1"># Use scipy to convert to yzx euler angles</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">scipy_Rotation</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">neg_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;yzx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="c1"># Return the tunnel angles</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="o">-</span><span class="n">neg_phi</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="transform_3d_point"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.transform_3d_point">[docs]</a><span class="k">def</span> <span class="nf">transform_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">obj_pts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform 3D points from the object frame to the camera frame.</span>

<span class="sd">    `rmat` and `tvec` are the transformation from the camera to the object&#39;s frame.</span>
<span class="sd">    ``obj_pts[i]`` is the position of point ``i`` relative to the object frame. The</span>
<span class="sd">    function returns the points relative to the camera.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    obj_pts : np.ndarray (n, 3), float</span>
<span class="sd">        List-like of 3D positions. The positions are relative to the object frame</span>
<span class="sd">        defined by rmat and tvec</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    np.ndarray (n, 3) of floats</span>
<span class="sd">        Array of transformed points. return[i] is the transformed obj_pts[i]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj_pts_tf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">tvec</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">obj_pts</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj_pts_tf</span></div>


<div class="viewcode-block" id="project_3d_point"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.project_3d_point">[docs]</a><span class="k">def</span> <span class="nf">project_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">obj_pts</span><span class="p">,</span> <span class="n">ret_jac</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_full_jac</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Projects targets into an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    obj_pts : np.ndarray, shape (n, 3), float</span>
<span class="sd">        The 3D position of the points on the object (relative to the object frame) to</span>
<span class="sd">        be projected</span>
<span class="sd">    ret_jac : bool, optional, default=False</span>
<span class="sd">        If True, returns the Jacobian. If False only the projection is returned</span>
<span class="sd">    ret_full_jac : bool, optional, default=False</span>
<span class="sd">        If True, returns full 15 term Jacobian (delta rvec, delta tvec, delta focal</span>
<span class="sd">        length, delta principal point, delta distortion). If False, returns the 6 term</span>
<span class="sd">        Jacobian (delta rvec, delta tvec)</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    projs, np.ndarray, shape (n, 2), float</span>
<span class="sd">        Projected pixel positions</span>
<span class="sd">    jacs : np.ndarray, shape (n, 2, 6) or (n, 2, 15), float</span>
<span class="sd">        Jacobian of the projected pixel location. Only returned if `ret_jac` is True.</span>
<span class="sd">        ``jacs[i]`` is associated with ``projs[i]``. ``jacs[:, 0, :]`` is the x axis,</span>
<span class="sd">        ``jacs[:, 1, :]`` is the y axis.  Axis 2 of `jacs` is the partial derivative</span>
<span class="sd">        related to the inputs (delta rvec, delta tvec, etc).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_pts</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># Convert the rmat into an rvec</span>
    <span class="n">rvec</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span>

    <span class="c1"># Project the points onto the image</span>
    <span class="n">obj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj_pts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">projs</span><span class="p">,</span> <span class="n">jacs</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">projectPoints</span><span class="p">(</span><span class="n">obj_pts</span><span class="p">,</span>
                                    <span class="n">rvec</span><span class="o">=</span><span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span><span class="o">=</span><span class="n">tvec</span><span class="p">,</span>
                                    <span class="n">cameraMatrix</span><span class="o">=</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="o">=</span><span class="n">distCoeffs</span><span class="p">)</span>

    <span class="c1"># Squeeze the extra dimension out</span>
    <span class="n">projs</span> <span class="o">=</span> <span class="n">projs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Add the jacobian if desired</span>
    <span class="k">if</span> <span class="n">ret_jac</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret_full_jac</span><span class="p">:</span>
            <span class="c1"># Crop just the delta-rotation-vector and delta-translation-vector terms</span>
            <span class="n">jacs</span> <span class="o">=</span> <span class="n">jacs</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span>

        <span class="c1"># Reshape jac so it has a dimension for pixel (u, v)</span>
        <span class="n">jacs</span> <span class="o">=</span> <span class="n">jacs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">jacs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">jacs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">projs</span><span class="p">,</span> <span class="n">jacs</span>

    <span class="c1"># If the jacobian is not required, return just he projected pixel locations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">projs</span></div>


<span class="c1">#---------------------------------------------------------------------------------------</span>
<span class="c1"># Target Functions</span>

<div class="viewcode-block" id="transform_targets"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.transform_targets">[docs]</a><span class="k">def</span> <span class="nf">transform_targets</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform the targets by the given transformation values.</span>

<span class="sd">    `rmat` and `tvec` are the transformation from the camera to the object&#39;s frame.</span>
<span class="sd">    ``tgts[i][&#39;tvec&#39;]`` is the position of target ``i`` relative to the object frame.</span>
<span class="sd">    ``tgts[i][&#39;norm&#39;]`` is the normal of target ``i`` relative to the object frame. The</span>
<span class="sd">    function returns the targets such that &#39;tvec&#39; and &#39;norm&#39; are relative to the camera.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) a &#39;tvec&#39;, and &#39;norm&#39; attribute. &#39;tvec&#39;</span>
<span class="sd">        is the position of the target relative to the object frame. &#39;norm&#39; is he normal</span>
<span class="sd">        of the target relative to the object frame. All other attributes will be copied</span>
<span class="sd">        to the transformed targets.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    tgts_tf : list of dict</span>
<span class="sd">        List of targets. Each target has the attributes of the input targets, except</span>
<span class="sd">        the transformed targets are transformed to be relative to the camera</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tgts_tf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="c1"># Transform the target tvec and norm to be relative to the camera</span>
        <span class="n">tgt_tf_tvec</span> <span class="o">=</span> <span class="n">transform_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tgt_tf_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">])</span>

        <span class="n">tgt_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
        <span class="n">tgt_copy</span><span class="p">[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_tf_tvec</span>
        <span class="n">tgt_copy</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgt_tf_norm</span>

        <span class="n">tgts_tf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt_copy</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tgts_tf</span></div>


<div class="viewcode-block" id="project_targets"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.project_targets">[docs]</a><span class="k">def</span> <span class="nf">project_targets</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Projects targets into an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (5, 1) or (5,), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) &#39;tvec&#39; and &#39;target_type&#39; attributes.</span>
<span class="sd">        The &#39;tvec&#39; attribute gives the target&#39;s location and &#39;target_type&#39; is a string</span>
<span class="sd">        denoting the type of target (most commonly &#39;dot&#39; or &#39;kulite&#39;)</span>
<span class="sd">    dims : array_like, length 2, optional</span>
<span class="sd">        Dimensions of image in (width, height). If not None, any targets that get</span>
<span class="sd">        projected outside the image (x &lt; 0, x &gt; dims[1], y &lt; 0, y &gt; dims[0]) will be</span>
<span class="sd">        None rather than having a value</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    list of dict</span>
<span class="sd">        List of target projections. Each target projections is a dict with the</span>
<span class="sd">        attributes &#39;target_type&#39; and &#39;proj&#39;. If `dims` is not None, some target</span>
<span class="sd">        projections may be None instead</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Package the 3D point translation vectors</span>
    <span class="n">obj_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">])</span>

    <span class="c1"># Project the points onto the image</span>
    <span class="n">projs</span> <span class="o">=</span> <span class="n">project_3d_point</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">obj_pts</span><span class="p">)</span>

    <span class="c1"># Repackage the projected points with their target type</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">proj</span><span class="p">,</span> <span class="n">tgt</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">projs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">):</span>
        <span class="n">tgt_projs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;target_type&#39;</span><span class="p">:</span> <span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;target_type&#39;</span><span class="p">],</span> <span class="s1">&#39;proj&#39;</span><span class="p">:</span> <span class="n">proj</span><span class="p">})</span>

    <span class="c1"># If dims is given, filter projections outside the image</span>
    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tgt_projs_temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tgt_proj</span> <span class="ow">in</span> <span class="n">tgt_projs</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">tgt_proj</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">]</span>
            <span class="c1"># If the point is within the image bounds given, add it to the temp list</span>
            <span class="k">if</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tgt_projs_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt_proj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tgt_projs_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">tgt_projs_temp</span>

    <span class="k">return</span> <span class="n">tgt_projs</span></div>


<div class="viewcode-block" id="get_occlusions_targets"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.get_occlusions_targets">[docs]</a><span class="k">def</span> <span class="nf">get_occlusions_targets</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper around :mod:`~upsp.cam_cal_utils.visibility` methods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) a &#39;tvec&#39;, and &#39;norm&#39; attribute. The</span>
<span class="sd">        &#39;tvec&#39; attribute gives the target&#39;s location and the &#39;norm&#39; attribute gives the</span>
<span class="sd">        target&#39;s normal vector</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    occlusions : list of tuple</span>
<span class="sd">        The first element of each tuple is a boolean. This boolean denotes if there was</span>
<span class="sd">        an occlusion or not. The second element of each tuple is the point that the</span>
<span class="sd">        occlusion happens. If there was no occlusion (the boolean from the first element</span>
<span class="sd">        would be False), the value [0, 0, 0] is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the position and orientation of the camera in the tgts frame</span>
    <span class="n">rmat_model2camera</span><span class="p">,</span> <span class="n">tvec_model2camera</span> <span class="o">=</span> <span class="n">invTransform</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">)</span>

    <span class="c1"># Package the tvecs and normals of the targets</span>
    <span class="n">tvecs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="n">tvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;tvec&#39;</span><span class="p">])</span>
        <span class="n">norms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">])</span>

    <span class="n">occlusions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tvecs</span><span class="p">,</span> <span class="n">norms</span><span class="p">)):</span>
        <span class="c1"># Unpackage the data</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">node_data</span>

        <span class="c1"># Check for occlusion</span>

        <span class="c1"># Get the direction of the ray</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">tvec_model2camera</span> <span class="o">-</span> <span class="n">node</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="c1"># Get the origin at a point differentiably close the the vertex</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">node</span> <span class="o">+</span> <span class="n">vis_checker</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">normal</span>

        <span class="c1"># If it is occluded, mark it occluded and move on to the next node</span>
        <span class="n">occlusions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vis_checker</span><span class="o">.</span><span class="n">does_intersect</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">occlusions</span></div>


<div class="viewcode-block" id="get_visible_targets"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.get_visible_targets">[docs]</a><span class="k">def</span> <span class="nf">get_visible_targets</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">vis_checker</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper around :meth:`~upsp.cam_cal_utils.visibility.VisibilityChecker.is_visible`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) a &#39;tvec&#39;, and &#39;norm&#39; attribute.  The</span>
<span class="sd">        &#39;tvec&#39; attribute gives the target&#39;s location and the &#39;norm&#39; attribute gives the</span>
<span class="sd">        target&#39;s normal vector. Both are np.ndarrays (n, 3) of floats. Returned targets</span>
<span class="sd">        will have the same additionalk attributes as the input targets</span>
<span class="sd">    vis_checker : ~upsp.cam_cal_utils.visibility.VisibilityChecker</span>
<span class="sd">        Visibility checker object with the relevant BVH and oblique viewing angle</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    list of dict</span>
<span class="sd">        List of visible targets. Returned targets are references to input targets.</span>
<span class="sd">        Returned list is the subset of the input targets that are visible to the camera</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the position and orientation of the camera in the tgts frame</span>
    <span class="n">rmat_model2camera</span><span class="p">,</span> <span class="n">tvec_model2camera</span> <span class="o">=</span> <span class="n">invTransform</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">)</span>

    <span class="c1"># Package the tvecs and normals of the targets</span>
    <span class="n">tvecs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">tgts</span><span class="p">:</span>
        <span class="n">tvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]))</span>
        <span class="n">norms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tgt</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]))</span>
    <span class="n">tvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tvecs</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">norms</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Get the visible targets and return</span>
    <span class="n">visible_indices</span> <span class="o">=</span> <span class="n">vis_checker</span><span class="o">.</span><span class="n">is_visible</span><span class="p">(</span><span class="n">tvec_model2camera</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">norms</span><span class="p">)</span>
    <span class="n">tgts_visibles</span> <span class="o">=</span> <span class="p">[</span><span class="n">tgts</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">visible_indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tgts_visibles</span></div>


<div class="viewcode-block" id="reprojection_error"><a class="viewcode-back" href="../../../_apidoc/upsp.cam_cal_utils.photogrammetry.html#upsp.cam_cal_utils.photogrammetry.reprojection_error">[docs]</a><span class="k">def</span> <span class="nf">reprojection_error</span><span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates RMS reprojection error</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmat : np.ndarray, shape (3, 3), float</span>
<span class="sd">        Rotation matrix from camera to object</span>
<span class="sd">    tvec : np.ndarray, shape (3, 1), float</span>
<span class="sd">        Translation vector from camera to object</span>
<span class="sd">    cameraMatrix : np.ndarray, shape (3, 3), float</span>
<span class="sd">        The (openCV formatted) camera matrix for the camera</span>
<span class="sd">    distCoeffs : np.ndarray, shape (1, 5), float</span>
<span class="sd">        The (openCV formatted) distortion coefficients for the camera</span>
<span class="sd">    tgts : list of dict</span>
<span class="sd">        Each target is a dict with (at a minimum) &#39;tvec&#39;, &#39;norm&#39;, and &#39;target_type&#39;</span>
<span class="sd">        attributes. The &#39;tvec&#39; attribute gives the target&#39;s location and the &#39;norm&#39;</span>
<span class="sd">        attribute gives the target&#39;s normal vector. &#39;target_type&#39; is a string denoting</span>
<span class="sd">        the type of target (most commonly &#39;dot&#39; or &#39;kulite&#39;)</span>
<span class="sd">    img_targets : list of dict</span>
<span class="sd">        Each ``img_target`` is a dict with (at a minimum) a &#39;center&#39; attribute. The</span>
<span class="sd">        &#39;center&#39; attribute gives the pixel position of the target&#39;s center in the image.</span>
<span class="sd">        ``img_targets[i]`` is associated with ``tgts[i]``</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    rms, max_dist : float</span>
<span class="sd">        RMS distance and maximum distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># Project inlier targets into image</span>
    <span class="n">tgt_projs</span> <span class="o">=</span> <span class="n">project_targets</span><span class="p">(</span>
        <span class="n">rmat</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">tgts</span><span class="p">)</span>

    <span class="c1"># Calculate the reprojection error</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_dist</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">proj</span><span class="p">,</span> <span class="n">img_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tgt_projs</span><span class="p">,</span> <span class="n">img_targets</span><span class="p">):</span>
        <span class="c1"># Get the Euclidean distance between the projection and detection img target</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">proj</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_pt</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;proj&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img_pt</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Check if this is the largest distance thus far</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>

        <span class="c1"># Add the square of the distance to the sum</span>
        <span class="n">rms</span> <span class="o">+=</span> <span class="n">dist</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Divide by the number of targets to get the mean of the squares</span>
    <span class="n">rms</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgts</span><span class="p">)</span>

    <span class="c1"># Take the square root to get the room mean square error</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rms</span><span class="p">,</span> <span class="n">max_dist</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, uPSP Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>