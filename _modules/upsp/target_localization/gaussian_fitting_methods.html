
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>upsp.target_localization.gaussian_fitting_methods &#8212; uPSP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">uPSP</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file-formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Third-Party Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../swdd.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../known-issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing this work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_apidoc/upsp.html"><code class="docutils literal notranslate"><span class="pre">upsp</span></code> Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for upsp.target_localization.gaussian_fitting_methods</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">opt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">OptimizeWarning</span>

<span class="kn">from</span> <span class="nn">upsp.target_localization.blob_detector_methods</span> <span class="kn">import</span> <span class="n">blob_func</span>


<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

<span class="n">super_gauss_power_upper_bound</span> <span class="o">=</span> <span class="mi">20</span>

<span class="c1">#---------------------------------------------------------------------------------------</span>
<span class="c1"># 2D Gaussian Functions</span>


<div class="viewcode-block" id="super_twoD_Gaussian"><a class="viewcode-back" href="../../../_apidoc/upsp.target_localization.gaussian_fitting_methods.html#upsp.target_localization.gaussian_fitting_methods.super_twoD_Gaussian">[docs]</a><span class="k">def</span> <span class="nf">super_twoD_Gaussian</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the value of a super 2D Gaussian function at the given point</span>

<span class="sd">    See https://en.wikipedia.org/wiki/Gaussian_function#Higher-order_Gaussian_or_super-Gaussian_function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt : np.ndarray, shape (N, 2), float</span>
<span class="sd">        2D Gaussian function point input. Length of output is equal to length of pt</span>
<span class="sd">    amplitude : float</span>
<span class="sd">        Amplitude of super 2D Gaussian</span>
<span class="sd">    xo, yo : float</span>
<span class="sd">        mean position of super 2D Gaussian (center of target)</span>
<span class="sd">    sx, sy: float</span>
<span class="sd">        standard deviations of super 2D Gaussian</span>
<span class="sd">    theta : float</span>
<span class="sd">        Angle of super 2D Gaussian ellipse</span>
<span class="sd">    offset : float</span>
<span class="sd">        Floor of super 2D Gaussian</span>
<span class="sd">    p : float</span>
<span class="sd">        Power of super 2D Gaussian. Higher power is more platykurtic</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.ndarray, shape (N, 1)</span>
<span class="sd">        Value of super 2D Gaussian function with given parameters at given point(s).</span>
<span class="sd">        Length of return is equal to length of the pt input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Seperate the point into x an y</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span>

    <span class="c1"># Get the x and y distance to the distribution&#39;s center</span>
    <span class="n">xval</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xo</span>
    <span class="n">yval</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">yo</span>

    <span class="c1"># Calculate the Quadratic Coefficients</span>
    <span class="n">cos_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">sin_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">sin2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">sx_sq</span> <span class="o">=</span> <span class="n">sx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">sy_sq</span> <span class="o">=</span> <span class="n">sy</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_sq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx_sq</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">sin_sq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sy_sq</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sx_sq</span><span class="p">))</span> <span class="o">+</span>   <span class="p">(</span><span class="n">sin2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sy_sq</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin_sq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx_sq</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos_sq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sy_sq</span><span class="p">))</span>

    <span class="c1"># Calculate the Gaussian value and scale by the amplitude</span>
    <span class="n">quad</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">xval</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">xval</span> <span class="o">*</span> <span class="n">yval</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">yval</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Exp the quadratic</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">quad</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">*=</span> <span class="n">amplitude</span>

    <span class="c1"># Add an offset</span>
    <span class="n">g</span> <span class="o">+=</span> <span class="n">offset</span>

    <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="twoD_Gaussian"><a class="viewcode-back" href="../../../_apidoc/upsp.target_localization.gaussian_fitting_methods.html#upsp.target_localization.gaussian_fitting_methods.twoD_Gaussian">[docs]</a><span class="k">def</span> <span class="nf">twoD_Gaussian</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to call :func:`super_twoD_Gaussian` with a power of 1</span>

<span class="sd">    See Also</span>
<span class="sd">    ----------</span>
<span class="sd">    super_twoD_Gaussian :</span>
<span class="sd">        Returns the value of a super 2D Gaussian function at the given point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">super_twoD_Gaussian</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="super_twoD_Gaussian_nobounds"><a class="viewcode-back" href="../../../_apidoc/upsp.target_localization.gaussian_fitting_methods.html#upsp.target_localization.gaussian_fitting_methods.super_twoD_Gaussian_nobounds">[docs]</a><span class="k">def</span> <span class="nf">super_twoD_Gaussian_nobounds</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ln_amplitude</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">ln_sx</span><span class="p">,</span> <span class="n">ln_sy</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ln_p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to call :func:`super_twoD_Gaussian` with no bounds on inputs</span>

<span class="sd">    For :func:`super_twoD_Gaussian`, the function does not make physical sense if</span>
<span class="sd">    amplitude, the standard deviations, or power are non-positive. (power must be &gt; 1</span>
<span class="sd">    for the function to be platykurtic)</span>

<span class="sd">    :func:`super_twoD_Gaussian_nobounds` is for optimizers that require no bounds. The</span>
<span class="sd">    natural logarithm of those values are passed to this function, and those values are</span>
<span class="sd">    passed through ``exp()`` before being passed to super_twoD_Gaussian. Those</span>
<span class="sd">    parameters can then vary from -inf to +inf, and will be mapped to (0, np.inf]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt : np.ndarray, shape (N, 2), float</span>
<span class="sd">        2D Gaussian function point input. Length of output is equal to length of pt</span>
<span class="sd">    ln_amplitude : float</span>
<span class="sd">        Natural log of the amplitude of super 2D Gaussian</span>
<span class="sd">    xo, yo : float</span>
<span class="sd">        mean position of super 2D Gaussian (center of target)</span>
<span class="sd">    ln_sx, ln_sy: float</span>
<span class="sd">        Natural log of standard deviations of super 2D Gaussian</span>
<span class="sd">    theta : float</span>
<span class="sd">        Angle of super 2D Gaussian ellipse</span>
<span class="sd">    offset : float</span>
<span class="sd">        Floor of super 2D Gaussian</span>
<span class="sd">    ln_p : float</span>
<span class="sd">        Natural log of the power of super 2D Gaussian minus 1. ``p = exp(ln_p) + 1``</span>
<span class="sd">        Higher power is more platykurtic.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    float or np.ndarray, shape (N, 1)</span>
<span class="sd">        Value of super 2D Gaussian function with given parameters at given point(s).</span>
<span class="sd">        Length of return is equal to length of the pt input</span>

<span class="sd">    See Also</span>
<span class="sd">    ----------</span>
<span class="sd">    super_twoD_Gaussian :</span>
<span class="sd">        Returns the value of a super 2D Gaussian function at the given point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">super_twoD_Gaussian</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_amplitude</span><span class="p">),</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_sx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_sy</span><span class="p">),</span> <span class="n">theta</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<span class="c1">#---------------------------------------------------------------------------------------</span>
<span class="c1"># Gaussian Target Localization</span>


<div class="viewcode-block" id="gauss_fitter_func"><a class="viewcode-back" href="../../../_apidoc/upsp.target_localization.gaussian_fitting_methods.html#upsp.target_localization.gaussian_fitting_methods.gauss_fitter_func">[docs]</a><span class="k">def</span> <span class="nf">gauss_fitter_func</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">get_rms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">curve_fit_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a function that acts as a wrapper around a 2D Gaussian function to act as</span>
<span class="sd">    a target center localizer</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fit : {&#39;super&#39;, &#39;normal&#39;}</span>
<span class="sd">        Specifies fitting function to use, super or standard 2D Gaussian</span>
<span class="sd">    get_rms : bool, optional</span>
<span class="sd">        If True, adds rms to output. If False does not</span>
<span class="sd">    curve_fit_kwds : dict, optional</span>
<span class="sd">        Keyword arguments for scipy curve fit optimizer. If None, the following keywords</span>
<span class="sd">        are used: ``{&#39;maxfev&#39; : 25000, &#39;ftol&#39; : 1e-4, &#39;xtol&#39; : 1e-4}``</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        If True, adds full optimization parameters and covariance matrix to output. If</span>
<span class="sd">        False does not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        2D Gaussian Fitting Function - returns center of target given an image</span>

<span class="sd">        Wrapper around optimizer of 2D Gaussian functions to act as target localization</span>
<span class="sd">        function.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        - ``img`` (:class:`numpy.ndarray`, 2 dimensional (grayscale), unint8) : Image</span>
<span class="sd">          with one target. Typically small</span>
<span class="sd">        - ``center`` (tuple of length 2, float): Initialization for target localization</span>
<span class="sd">        - ``target_type`` (``{&#39;dot&#39;, &#39;kulite&#39;, None}``): Type of target in image. Used</span>
<span class="sd">          to initialize target finding parameters</span>
<span class="sd">        - ``img_offset`` (tuple or None): Since the center location is from the whole</span>
<span class="sd">          image, and the localizer is a local function, the offset tells where the</span>
<span class="sd">          center location is in the local image. Additionally, output is offset by</span>
<span class="sd">          `img_offset` to give the target&#39;s location in the whole image. If None, do</span>
<span class="sd">          none of that.</span>

<span class="sd">        Returns:</span>

<span class="sd">            If `debug` input is False, return tuple contains center as first item.</span>
<span class="sd">            Center is a tuple of 2 floats denoting the target x and y position.</span>

<span class="sd">            If `get_rms` is True, return tuple contains rms error as second item. If</span>
<span class="sd">            `get_rms` is False, return tuple has no second item.</span>

<span class="sd">            If `debug` input is True, return tuple contains an inner tuple as the first</span>
<span class="sd">            item. The inner tuple contains the full set of optimizer parameters as the</span>
<span class="sd">            first item, and the covariance matrix as the second item.</span>

<span class="sd">            If there is an error in the optimization, all None&#39;s will be returned for the</span>
<span class="sd">            center, optimizer parameters, covatiance matrix, and rms as needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fit</span> <span class="o">==</span> <span class="s1">&#39;super&#39;</span><span class="p">):</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="n">super_twoD_Gaussian</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">fit</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">):</span>
        <span class="n">fitter</span> <span class="o">=</span> <span class="n">twoD_Gaussian</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Specified fitter does not exist.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fitter must be &#39;super&#39; or &#39;normal&#39;&quot;</span><span class="p">)</span>
        <span class="n">quit</span><span class="p">()</span>

    <span class="n">blob_detector</span> <span class="o">=</span> <span class="n">blob_func</span><span class="p">(</span><span class="s1">&#39;detector_all&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">OptimizeWarning</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;.*Covariance of the parameters could not be estimated*.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">curve_fit_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curve_fit_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maxfev&#39;</span><span class="p">:</span> <span class="mi">25000</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">fit_gaussian</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">img_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns center of target given an image</span>

<span class="sd">        Wrapper around optimizer of 2D Gaussian functions to act as target localization</span>
<span class="sd">        function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img : np.ndarray, 2 dimensional (grayscale), unint8</span>
<span class="sd">            Image with one target. Typically small</span>
<span class="sd">        center : tuple of length 2, float or None. Optional, default=None</span>
<span class="sd">            Initialization for target localization. If None, blob detection is performed</span>
<span class="sd">            to initalize the target position</span>
<span class="sd">        target_type : {&#39;dot&#39;, &#39;kulite&#39;, None}, default=None</span>
<span class="sd">            Type of target in image. Used to initialize target finding parameters</span>
<span class="sd">        img_offset : tuple or None, default=None</span>
<span class="sd">            Since the center location is from the whole image, and the localizer</span>
<span class="sd">            is a local function, the offset tells where the center location is in</span>
<span class="sd">            the local image. Additionally, output is offset by img_offset to give the</span>
<span class="sd">            target&#39;s location in the whole image. If None, do none of that.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        tuple</span>
<span class="sd">            If gauss_fitter_func&#39;s debug input is False, return tuple contains center as</span>
<span class="sd">            first item. Center is a tuple of 2 floats denoting the target x and y</span>
<span class="sd">            position. If gauss_fitter_func&#39;s get_rms is True, return tuple contains</span>
<span class="sd">            rms error as second item. If get_rms is False, return tuple has no second</span>
<span class="sd">            item.</span>
<span class="sd">            If gauss_fitter_func&#39;s debug input is True, return tuple contains an inner</span>
<span class="sd">            tuple as the first itme. The inner tuple contains the full set of optimizer</span>
<span class="sd">            parameters as the first item, and the covariance matrix as the second item.</span>
<span class="sd">            If gauss_fitter_func&#39;s get_rms is True, return tuple contains rms error as</span>
<span class="sd">            the second item. If get_rms is False, return tuple has no second item.</span>
<span class="sd">            If there is an error in the optimization, all None&#39;s will be returned for the</span>
<span class="sd">            center, optimizer parameters, covatiance matrix, and rms as needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a keypoint was not given as input, find one with a blob detector</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keypoint</span> <span class="o">=</span> <span class="n">blob_detector</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">return_keypoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># If the blob detector didn&#39;t find a keypoint, initialize one based</span>
            <span class="c1">#   on a reasonable guess</span>
            <span class="k">if</span> <span class="n">keypoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">keypoint</span><span class="o">.</span><span class="n">pt</span>

        <span class="c1"># Populate initial guess information based on the center input</span>
        <span class="n">center_x</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_y</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># img_offset serves to help if the center input than the input image</span>
        <span class="c1">#   (as is the case with cropping)</span>
        <span class="k">if</span> <span class="n">img_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center_x</span> <span class="o">-=</span> <span class="n">img_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">center_y</span> <span class="o">-=</span> <span class="n">img_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Populate the initial guess for size_x and size_y based on target type</span>
        <span class="k">if</span> <span class="n">target_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size_x</span> <span class="o">=</span> <span class="mf">0.75</span>
            <span class="n">size_y</span> <span class="o">=</span> <span class="mf">0.75</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;kulite&#39;</span><span class="p">):</span>
                <span class="n">size_x</span> <span class="o">=</span> <span class="mf">0.8</span>
                <span class="n">size_y</span> <span class="o">=</span> <span class="mf">0.8</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;dot&#39;</span><span class="p">):</span>
                <span class="n">size_x</span> <span class="o">=</span> <span class="mf">1.2</span>
                <span class="n">size_y</span> <span class="o">=</span> <span class="mf">1.2</span>

        <span class="c1"># Initialize the guess for angle to 0</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># For scipy.curve_fit, img needs to be a float</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Targets are dark dots (dips in intensity relative to background)</span>
        <span class="c1"># To make the gaussian fit more intuitive, multiply the image by -1</span>
        <span class="c1">#   so they are now bright dots relative to the background (raises in</span>
        <span class="c1">#   intensity relative to background)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="o">-</span><span class="n">img</span>

        <span class="c1"># Create the grid of pixel locations as a two 2D numpy arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Unravel the grid points and image into corresponding</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Populate an initial guess estimate for the curve fit</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">img</span><span class="p">),</span>
                         <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span>
                         <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">img</span><span class="p">)]</span>

        <span class="c1"># Set the bounds for the inputs</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>  <span class="c1"># Amplitude bounds</span>
                  <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># center location bounds</span>
                  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>  <span class="c1"># std dev bounds</span>
                  <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>  <span class="c1"># angle bounds</span>
                  <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="nb">max</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))]</span>

        <span class="c1"># If this is using a super gauss add the additional p term for the initial</span>
        <span class="c1">#   guess and bounds</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fit</span> <span class="o">==</span> <span class="s1">&#39;super&#39;</span><span class="p">):</span>
            <span class="c1"># Populate the initial guess for power based on target type</span>
            <span class="k">if</span> <span class="n">target_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">init_guess_p</span> <span class="o">=</span> <span class="mf">2.6</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;kulite&#39;</span><span class="p">):</span>
                    <span class="n">init_guess_p</span> <span class="o">=</span> <span class="mf">1.8</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;dot&#39;</span><span class="p">):</span>
                    <span class="n">init_guess_p</span> <span class="o">=</span> <span class="mf">3.2</span>

            <span class="n">initial_guess</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_guess_p</span><span class="p">)</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">super_gauss_power_upper_bound</span><span class="p">))</span>

        <span class="c1"># Re-arange the bounds into the form that scipy accepts</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">],</span> <span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]]</span>

        <span class="c1"># Create an return value object to store the output</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">fitter</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trf&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">curve_fit_kwds</span><span class="p">)</span>

            <span class="c1"># If debug is on, append the full popt and pconv</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">))</span>

            <span class="c1"># If debug is off, append the center location as a tuple to the return value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_opt</span><span class="p">,</span> <span class="n">y_opt</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">img_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">x_opt</span> <span class="o">+=</span> <span class="n">img_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">y_opt</span> <span class="o">+=</span> <span class="n">img_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x_opt</span><span class="p">,</span> <span class="n">y_opt</span><span class="p">)))</span>

            <span class="c1"># If retval is on, calculate the rms and append</span>
            <span class="k">if</span> <span class="n">get_rms</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">z_hat</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

                <span class="c1"># Debug visualizations</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;img&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;debug_img.png&#39;</span><span class="p">)</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;z_hat&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z_hat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;debug_zhat.png&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">get_rms</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">z_hat</span>
                    <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">error</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rms</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Since there was a runtime error, throw a warning and return the None flags</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

            <span class="c1"># If debug is on, append arrays of the appropriate size for popt and pconv</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">popt</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">popt</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)))</span>

            <span class="c1"># If debug is off, just append (None, None) as the center location</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>

            <span class="c1"># If get_rms is on, append None</span>
            <span class="k">if</span> <span class="n">get_rms</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Since there was a runtime error, throw a warning and return the None flags</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

            <span class="c1"># If debug is on, append arrays of the appropriate size for popt and pconv</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">),</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">)),</span> <span class="kc">None</span><span class="p">))</span>

            <span class="c1"># If debug is off, just append (None, None) as the center location</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="c1"># If get_rms is on, append None</span>
            <span class="k">if</span> <span class="n">get_rms</span><span class="p">:</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

        <span class="c1"># Return a tuple of the return value (converting from list)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fit_gaussian</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, uPSP Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>